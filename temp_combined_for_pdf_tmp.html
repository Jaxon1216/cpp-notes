<!DOCTYPE html>
<html>
<head>
<title>temp_combined_for_pdf.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong>：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p>
<!--more-->
<p>示例：</p>
<ul>
<li>算法：<code>sort(a.begin(), a.end())</code></li>
<li>容器：<code>priority_queue&lt;int&gt; pque</code></li>
<li>仿函数：<code>greater&lt;int&gt;()</code></li>
<li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li>
</ul>
<h1 id="1-%E5%89%8D%E8%A8%80">1 前言</h1>
<p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <s>往往</s> 更顺利。</p>
<p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p>
<p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p>
<h1 id="2-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">2 常用容器</h1>
<h2 id="21-%E5%86%85%E5%AE%B9%E6%80%BB%E8%A7%88">2.1 内容总览</h2>
<p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p>
<ul>
<li>
<p>顺序容器</p>
<ul>
<li>
<p><input type="checkbox" id="checkbox0"><label for="checkbox0"></label><strong>array</strong></p>
</li>
<li>
<p><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1"></label><strong>vector</strong></p>
</li>
<li>
<p><input type="checkbox" id="checkbox2"><label for="checkbox2"></label><strong>deque</strong></p>
</li>
<li>
<p><input type="checkbox" id="checkbox3"><label for="checkbox3">forward_list</label></p>
</li>
<li>
<p><input type="checkbox" id="checkbox4"><label for="checkbox4"></label><strong>list</strong></p>
</li>
</ul>
</li>
<li>
<p>关联容器</p>
<ul>
<li><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5"></label><strong>set</strong></li>
<li><input type="checkbox" id="checkbox6" checked="true"><label for="checkbox6"></label><strong>map</strong></li>
<li><input type="checkbox" id="checkbox7"><label for="checkbox7"></label><strong>multiset</strong></li>
<li><input type="checkbox" id="checkbox8"><label for="checkbox8"></label><strong>multimap</strong></li>
</ul>
</li>
<li>
<p>无序关联容器</p>
<ul>
<li><input type="checkbox" id="checkbox9"><label for="checkbox9"></label><strong>unordered_set</strong></li>
<li><input type="checkbox" id="checkbox10"><label for="checkbox10"></label><strong>unordered_map</strong></li>
<li><input type="checkbox" id="checkbox11"><label for="checkbox11"></label><strong>unordered_multiset</strong></li>
<li><input type="checkbox" id="checkbox12"><label for="checkbox12"></label><strong>unordered_multimap</strong></li>
</ul>
</li>
<li>
<p>容器适配器</p>
<ul>
<li><input type="checkbox" id="checkbox13" checked="true"><label for="checkbox13"></label><strong>stack</strong></li>
<li><input type="checkbox" id="checkbox14" checked="true"><label for="checkbox14"></label><strong>queue</strong></li>
<li><input type="checkbox" id="checkbox15" checked="true"><label for="checkbox15"></label><strong>priority_queue</strong></li>
<li><input type="checkbox" id="checkbox16"><label for="checkbox16">flat_set</label></li>
<li><input type="checkbox" id="checkbox17"><label for="checkbox17">flat_map</label></li>
<li><input type="checkbox" id="checkbox18"><label for="checkbox18">flat_multiset</label></li>
<li><input type="checkbox" id="checkbox19"><label for="checkbox19">flat_multimap</label></li>
</ul>
</li>
<li>
<p>字符串</p>
<ul>
<li><input type="checkbox" id="checkbox20" checked="true"><label for="checkbox20"></label><strong>string</strong> (basic_string&lt;char&gt;)</li>
</ul>
</li>
<li>
<p>对与元组</p>
<ul>
<li><input type="checkbox" id="checkbox21" checked="true"><label for="checkbox21"></label><strong>pair</strong></li>
<li><input type="checkbox" id="checkbox22"><label for="checkbox22"></label><strong>tuple</strong></li>
</ul>
</li>
</ul>
<h2 id="22-%E5%90%91%E9%87%8F-vector">2.2 向量 <a href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2>
<p><strong><code>#include &lt;vector&gt;</code></strong></p>
<p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p>
<h3 id="221-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.2.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p>
<p>时间复杂度：$O(n)$</p>
<p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;         <span class="hljs-comment">// 构造int数组</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;    <span class="hljs-comment">// 构造初始长100的int数组</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 构造初始长100的int数组，初值为1</span>

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">mat</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ())</span></span>;       <span class="hljs-comment">// 构造初始100行，不指定列数的二维数组</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">mat</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; (<span class="hljs-number">666</span>, <span class="hljs-number">-1</span>))</span> <span class="hljs-comment">// 构造初始100行，初始666列的二维数组，初值为-1</span>
</span></div></code></pre>
<p>构造二维数组的奇葩写法，千万别用：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr[<span class="hljs-number">100</span>];         <span class="hljs-comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr[<span class="hljs-number">100</span>](<span class="hljs-number">100</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 语法错误！</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span>[100]</span>; <span class="hljs-comment">// 语法错误！</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr[<span class="hljs-number">100</span>] {{<span class="hljs-number">100</span>, <span class="hljs-number">1</span>}, 这里省略<span class="hljs-number">98</span>个 ,{<span class="hljs-number">100</span>, <span class="hljs-number">1</span>}}; <span class="hljs-comment">// 正确但奇葩，使用列表初始化</span>
</div></code></pre>
<h4 id="%E5%B0%BE%E6%8E%A5--%E5%B0%BE%E5%88%A0">尾接 &amp; 尾删</h4>
<ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素，数组长度 $+1$.</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素，数组长度 $-1$</li>
</ul>
<p>时间复杂度：均摊 $O(1)$</p>
<pre class="hljs"><code><div><span class="hljs-comment">// init: arr = []</span>
arr.push_back(<span class="hljs-number">1</span>);
<span class="hljs-comment">// after: arr = [1]</span>
arr.push_back(<span class="hljs-number">2</span>);
<span class="hljs-comment">// after: arr = [1, 2]</span>
arr.pop_back();
<span class="hljs-comment">// after: arr = [1]</span>
arr.pop_back();
<span class="hljs-comment">// after: arr = []</span>
</div></code></pre>
<h4 id="%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6">中括号运算符</h4>
<p>和一般数组一样的作用</p>
<p>时间复杂度：$O(1)$</p>
<h4 id="%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6">获取长度</h4>
<p><strong><code>.size()</code></strong></p>
<p>获取当前 vector 的长度</p>
<p>时间复杂度：$O(1)$</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++)
    <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E6%B8%85%E7%A9%BA">清空</h4>
<p><strong><code>.clear()</code></strong></p>
<p>清空 vector</p>
<p>时间复杂度：$O(n)$</p>
<h4 id="%E5%88%A4%E7%A9%BA">判空</h4>
<p><strong><code>.empty()</code></strong></p>
<p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：$O(1)$</p>
<h4 id="%E6%94%B9%E5%8F%98%E9%95%BF%E5%BA%A6">改变长度</h4>
<p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<ul>
<li>如果是缩短，则删除多余的值</li>
<li>如果是扩大，且指定了默认值，则新元素均为默认值 <strong>（旧元素不变）</strong></li>
</ul>
<p>时间复杂度：$O(n)$</p>
<h3 id="222-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.2.2 适用情形</h3>
<p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p>
<p>有些情况普通数组没法解决：$n\times m$ 的矩阵，$1\leq n,m\leq 10^6$ 且 $n\times m \leq 10^6$</p>
<ul>
<li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li>
<li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li>
</ul>
<p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p>
<h3 id="223-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.2.3 注意事项</h3>
<h4 id="%E6%8F%90%E5%89%8D%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6">提前指定长度</h4>
<p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 优化前: 522ms</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e8</span>; i++)
    a.push_back(i);
<span class="hljs-comment">// 优化后: 259ms</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1e8</span>)</span></span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i++)
    a[i] = i;
</div></code></pre>
<h4 id="%E5%BD%93%E5%BF%83-sizet-%E6%BA%A2%E5%87%BA">当心 size_t 溢出</h4>
<p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">65536</span>)</span></span>;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = a.size() * a.size(); <span class="hljs-comment">// 直接溢出变成0了</span>
</div></code></pre>
<h2 id="23-%E6%A0%88-stack">2.3 栈 <a href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2>
<p><strong><code>#include &lt;stack&gt;</code></strong></p>
<p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p>
<h3 id="231-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.3.1 常用方法</h3>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造</td>
<td><code>stack&lt;类型&gt; stk</code></td>
<td><code>stack&lt;int&gt; stk;</code></td>
</tr>
<tr>
<td>进栈</td>
<td><code>.push(元素)</code></td>
<td><code>stk.push(1);</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>.pop()</code></td>
<td><code>stk.pop();</code></td>
</tr>
<tr>
<td>取栈顶</td>
<td><code>.top()</code></td>
<td><code>int a = stk.top();</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<h3 id="232-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.3.2 适用情形</h3>
<p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p>
<p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h3 id="233-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.3.3 注意事项</h3>
<p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stk.size(); i++)
    <span class="hljs-built_in">cout</span> &lt;&lt; stk[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ele : stk)
    <span class="hljs-built_in">cout</span> &lt;&lt; stk &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h2 id="24-%E9%98%9F%E5%88%97-queue">2.4 队列 <a href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2>
<p><strong><code>#include &lt;queue&gt;</code></strong></p>
<p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p>
<h3 id="241-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.4.1 常用方法</h3>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造</td>
<td><code>queue&lt;类型&gt; que</code></td>
<td><code>queue&lt;int&gt; que;</code></td>
</tr>
<tr>
<td>进队</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取队首</td>
<td><code>.front()</code></td>
<td><code>int a = que.front();</code></td>
</tr>
<tr>
<td>取队尾</td>
<td><code>.back()</code></td>
<td><code>int a = que.back();</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<h3 id="242-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.4.2 适用情形</h3>
<p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p>
<h3 id="243-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.4.3 注意事项</h3>
<p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; que.size(); i++)
    <span class="hljs-built_in">cout</span> &lt;&lt; que[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ele : que)
    <span class="hljs-built_in">cout</span> &lt;&lt; ele &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h2 id="25-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priorityqueue">2.5 优先队列 <a href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2>
<p><strong><code>#include &lt;queue&gt;</code></strong></p>
<p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p>
<h3 id="251-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.5.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<pre class="hljs"><code><div>priority_queue&lt;<span class="hljs-keyword">int</span>&gt; pque1;                            <span class="hljs-comment">// 储存int的大顶堆</span>
priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pque2; <span class="hljs-comment">// 储存int的小顶堆</span>
</div></code></pre>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p>
</blockquote>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>进堆</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出堆</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取堆顶</td>
<td><code>.top()</code></td>
<td><code>int a = que.top();</code></td>
</tr>
<tr>
<td>查看大小 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>进出队复杂度 $O(\log n)$，取堆顶 $O(1)$.</p>
<h3 id="252-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.5.2 适用情形</h3>
<p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 $n$，插入操作数量 $k$.</p>
<ul>
<li>每次插入后进行快速排序：$k\cdot n\log n$</li>
<li>使用优先队列维护：$k\cdot\log n$</li>
</ul>
<h3 id="253-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.5.3 注意事项</h3>
<h4 id="%E4%BB%85%E5%A0%86%E9%A1%B6%E5%8F%AF%E8%AF%BB">仅堆顶可读</h4>
<p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; pque[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E5%86%99">所有元素不可写</h4>
<p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div>pque[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
pque.top() = <span class="hljs-number">1</span>;
</div></code></pre>
<p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> tp = pque.top();
pque.pop();
pque.push(tp + <span class="hljs-number">1</span>);
</div></code></pre>
<h2 id="26-%E9%9B%86%E5%90%88-set">2.6 集合 <a href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2>
<p><strong><code>#include &lt;set&gt;</code></strong></p>
<p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p>
<table>
<thead>
<tr>
<th>集合三要素</th>
<th>解释</th>
<th>set</th>
<th>multiset</th>
<th>unordered_set</th>
</tr>
</thead>
<tbody>
<tr>
<td>确定性</td>
<td>一个元素要么在集合中，要么不在</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>互异性</td>
<td>一个元素仅可以在集合中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>集合中的元素是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody>
</table>
<h3 id="261-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.6.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; st1;               <span class="hljs-comment">// 储存int的集合（从小到大）</span>
<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; st2; <span class="hljs-comment">// 储存int的集合（从大到小）</span>
</div></code></pre>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p>
</blockquote>
<h4 id="%E6%9F%A5%E6%89%BE">查找</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (st.find(val) != st.end()){};
<span class="hljs-comment">//还可以用count（val）返回有几个val，根据互异性，只可能有0，1两种返回值；</span>
<span class="hljs-keyword">if</span>(st.count(<span class="hljs-number">2</span>)){};
</div></code></pre>
<h4 id="%E9%81%8D%E5%8E%86">遍历</h4>
<p>可使用迭代器进行遍历：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); ++it)
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>基于范围的循环（C++ 11）：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ele : st)
    <span class="hljs-built_in">cout</span> &lt;&lt; ele &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入元素</td>
<td><code>.insert(元素)</code></td>
<td><code>st.insert(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>st.erase(2);</code></td>
</tr>
<tr>
<td>查找元素</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = st.find(1);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>st.count(3);</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>增删查时间复杂度均为 $O(\log n)$</p>
<h3 id="262-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.6.2 适用情形</h3>
<ul>
<li>元素去重：$[1,1,3,2,4,4]\to[1,2,3,4]$</li>
<li>维护顺序：$[1,5,3,7,9]\to[1,3,5,7,9]$</li>
<li>元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。</li>
</ul>
<h3 id="263-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.6.3 注意事项</h3>
<h4 id="%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95">不存在下标索引</h4>
<p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; st[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E5%85%83%E7%B4%A0%E5%8F%AA%E8%AF%BB">元素只读</h4>
<p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; *st.begin() &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 正确。可读。</span>
*st.begin() = <span class="hljs-number">1</span>;             <span class="hljs-comment">// 错误！不可写！</span>
</div></code></pre>
<h4 id="%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%A1%E7%AE%97%E4%B8%8B%E6%A0%87">不可用迭代器计算下标</h4>
<p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> it = st.find(<span class="hljs-number">2</span>);      <span class="hljs-comment">// 正确，返回2所在位置的迭代器。</span>
<span class="hljs-keyword">int</span> idx = it - st.begin(); <span class="hljs-comment">// 错误！不可相减得到下标。</span>
</div></code></pre>
<h2 id="27-%E6%98%A0%E5%B0%84-map">2.7 映射 <a href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2>
<p><strong><code>#include &lt;map&gt;</code></strong></p>
<p>提供对数时间的有序键值对结构。底层原理是红黑树。</p>
<p>映射：
$$
\begin{matrix}
1&amp;\to&amp;2\
2&amp;\to&amp;2\
3&amp;\to&amp;1\
4&amp;\to&amp;5\
&amp;\vdots
\end{matrix}
$$</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>解释</th>
<th>map</th>
<th>multimap</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody>
<tr>
<td>互异性</td>
<td>一个键仅可以在映射中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>键是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody>
</table>
<h3 id="271-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.7.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p>
<ul>
<li>键类型：要储存键的数据类型</li>
<li>值类型：要储存值的数据类型</li>
<li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp1;               <span class="hljs-comment">// int-&gt;int 的映射（键从小到大）</span>
<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; st2; <span class="hljs-comment">// int-&gt;int 的映射（键从大到小）</span>
</div></code></pre>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p>
</blockquote>
<h4 id="%E9%81%8D%E5%8E%86">遍历</h4>
<p>可使用迭代器进行遍历：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it)
    <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>基于范围的循环（C++ 11）：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pr : mp)
    <span class="hljs-built_in">cout</span> &lt;&lt; pr.first &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; pr.second &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>结构化绑定 + 基于范围的循环（C++17）：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[key, val] : mp)
    <span class="hljs-built_in">cout</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; val &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>增 / 改 / 查元素</td>
<td>中括号</td>
<td><code>mp[1] = 2;</code></td>
</tr>
<tr>
<td>查元素（返回迭代器）</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = mp.find(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>mp.erase(2);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>mp.count(3);</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
<p>增删改查时间复杂度均为 $O(\log n)$</p>
<h3 id="272-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.7.2 适用情形</h3>
<p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p>
<h3 id="273-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.7.3 注意事项</h3>
<h4 id="%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%AE%BF%E9%97%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%80%BC">中括号访问时默认值</h4>
<p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;
<span class="hljs-built_in">cout</span> &lt;&lt; mp.count(<span class="hljs-string">'a'</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 0</span>
mp[<span class="hljs-string">'a'</span>];                       <span class="hljs-comment">// 即使什么都没做，此时mp['a']=0已经插入了</span>
<span class="hljs-built_in">cout</span> &lt;&lt; mp.count(<span class="hljs-string">'a'</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">cout</span> &lt;&lt; mp[<span class="hljs-string">'a'</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;       <span class="hljs-comment">// 0</span>
</div></code></pre>
<h4 id="%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%A1%E7%AE%97%E4%B8%8B%E6%A0%87">不可用迭代器计算下标</h4>
<p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">auto</span> it = mp.find(<span class="hljs-string">'a'</span>);      <span class="hljs-comment">// 正确，返回2所在位置的迭代器。</span>
<span class="hljs-keyword">int</span> idx = it - mp.begin();   <span class="hljs-comment">// 错误！不可相减得到下标。</span>
</div></code></pre>
<h2 id="28-%E5%AD%97%E7%AC%A6%E4%B8%B2-string">2.8 字符串 <a href="https://zh.cppreference.com/w/cpp/string">string</a></h2>
<p><strong><code>#include &lt;string&gt;</code></strong></p>
<p>顾名思义，就是储存字符串的。</p>
<h3 id="281-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.8.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p>构造函数：<code>string(长度, 初值)</code></p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s1;           <span class="hljs-comment">// 构造字符串，为空</span>
<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">"awa!"</span>;  <span class="hljs-comment">// 构造字符串，并赋值awa!</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">'6'</span>)</span></span>;  <span class="hljs-comment">// 构造字符串，通过构造函数构造为6666666666</span>
</div></code></pre>
<h4 id="%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</h4>
<p>C++</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s;
<span class="hljs-built_in">cin</span> &gt;&gt; s;
<span class="hljs-built_in">cout</span> &lt;&lt; s;
</div></code></pre>
<p>C</p>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, &amp;buf);
s = buf;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, s.c_str());
</div></code></pre>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>修改、查询指定下标字符</td>
<td><code>[]</code></td>
<td><code>s[1] = 'a';</code></td>
</tr>
<tr>
<td>是否相同</td>
<td><code>==</code></td>
<td><code>if (s1 == s2) ...</code></td>
</tr>
<tr>
<td>字符串连接</td>
<td><code>+</code></td>
<td><code>string s = s1 + s2;</code></td>
</tr>
<tr>
<td>尾接字符串</td>
<td><code>+=</code></td>
<td><code>s += &quot;awa&quot;;</code></td>
</tr>
<tr>
<td>取子串</td>
<td><code>.substr(起始下标, 子串长度)</code></td>
<td><code>string sub = s.substr(2, 10);</code></td>
</tr>
<tr>
<td>查找字符串</td>
<td><code>.find(字符串, 起始下标)</code></td>
<td><code>int pos = s.find(&quot;awa&quot;);</code></td>
</tr>
</tbody>
</table>
<h4 id="%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E8%BD%ACc11">数值与字符串互转（C++11）</h4>
<table>
<thead>
<tr>
<th>源</th>
<th>目的</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>int / long long / float / double / long double</td>
<td>string</td>
<td>to_string()</td>
</tr>
<tr>
<td>string</td>
<td>int</td>
<td>stoi()</td>
</tr>
<tr>
<td>string</td>
<td>long long</td>
<td>stoll()</td>
</tr>
<tr>
<td>string</td>
<td>float</td>
<td>stof()</td>
</tr>
<tr>
<td>string</td>
<td>double</td>
<td>stod()</td>
</tr>
<tr>
<td>string</td>
<td>long double</td>
<td>stold()</td>
</tr>
</tbody>
</table>
<h3 id="282-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">2.8.2 适用情形</h3>
<p>非常好用！<s>建议直接把字符数组扔了，赶快投入 string 的怀抱。</s></p>
<h3 id="283-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.8.3 注意事项</h3>
<h4 id="%E5%B0%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8">尾接字符串一定要用 <code>+=</code></h4>
<p>string 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.</p>
<p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 优化前: 15139ms</span>
<span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5e5</span>; i++)
    s = s + <span class="hljs-string">"a"</span>;

<span class="hljs-comment">// 优化后: &lt; 1ms (计时器显示0)</span>
<span class="hljs-built_in">string</span> s;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5e5</span>; i++)
    s += <span class="hljs-string">"a"</span>;
</div></code></pre>
<h4 id="substr-%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E8%91%A9%E5%8F%82%E6%95%B0"><code>.substr()</code> 方法的奇葩参数</h4>
<p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p>
<p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p>
<h4 id="find-%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><code>.find()</code> 方法的复杂度</h4>
<p>该方法实现为暴力实现，时间复杂度为 $O(n^2)$.</p>
<p><s>不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法</s></p>
<h2 id="29-%E4%BA%8C%E5%85%83%E7%BB%84-pair">2.9 二元组 <a href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2>
<p><strong><code>#include &lt;utility&gt;</code></strong></p>
<p>顾名思义，就是储存二元组的。</p>
<h3 id="291-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.9.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p>
<ul>
<li>第一个值类型：要储存的第一个值的数据类型</li>
<li>第二个值类型：要储存的第二个值的数据类型</li>
</ul>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p1;
pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; p2;
pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; p3;
<span class="hljs-comment">// ...</span>
</div></code></pre>
<h4 id="%E8%B5%8B%E5%80%BC">赋值</h4>
<p>老式</p>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>&gt; pr = make_pair(<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>);
</div></code></pre>
<p>列表构造 C++11</p>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>&gt; pr = {<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>};
</div></code></pre>
<h4 id="%E5%8F%96%E5%80%BC">取值</h4>
<p>直接取值</p>
<ul>
<li>取第一个值：<code>.first</code></li>
<li>取第二个值：<code>.second</code></li>
</ul>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>&gt; pr = {<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>};
<span class="hljs-keyword">int</span> awa = pr.first;
<span class="hljs-keyword">char</span> bwb = pr.second;
</div></code></pre>
<p>结构化绑定 C++17</p>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>&gt; pr = {<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>};
<span class="hljs-keyword">auto</span> &amp;[awa, bwb] = pr;
</div></code></pre>
<h4 id="%E5%88%A4%E5%90%8C">判同</h4>
<p>直接用 <code>==</code> 运算符</p>
<pre class="hljs"><code><div>pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p2 = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">if</span> (p1 == p2) { ... } <span class="hljs-comment">// false</span>
</div></code></pre>
<h3 id="292-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">2.9.2 适用场景</h3>
<p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p>
<h3 id="293-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.9.3 注意事项</h3>
<p>无</p>
<h1 id="3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%AE%80%E4%BB%8B">3 迭代器简介</h1>
<h2 id="31-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88">3.1 迭代器是什么？</h2>
<p>不搞抽象，直接举例。</p>
<p>对于一个 vector，我们可以用下标遍历：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i++)
    <span class="hljs-built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>我们同时也可以用迭代器来遍历：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = a.begin(); it != a.end(); ++it)
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<ul>
<li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li>
<li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li>
<li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li>
<li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li>
</ul>
<h2 id="32-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8">3.2 为何需要迭代器？</h2>
<p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p>
<p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p>
<p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); ++it)
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h2 id="33-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E6%B3%95">3.3 迭代器用法</h2>
<p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p>
<ul>
<li><code>.begin()</code>：头迭代器</li>
<li><code>.end()</code>：尾迭代器</li>
<li><code>.rbegin()</code>：反向头迭代器</li>
<li><code>.rend()</code>：反向尾迭代器</li>
<li>迭代器 <code>+</code> 整型：将迭代器向后移动</li>
<li>迭代器 <code>-</code> 整型：将迭代器向前移动</li>
<li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li>
<li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li>
<li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li>
<li><code>prev(it)</code>：返回 it 的前一个迭代器</li>
<li><code>next(it)</code>：返回 it 的后一个迭代器</li>
</ul>
<p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 <strong>set</strong> 的迭代器是不能相减求距离的）</p>
<h2 id="34-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">3.4 常见问题</h2>
<p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p>
<p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p>
<p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p>
<p><strong>不同容器的迭代器功能可能不一样</strong></p>
<p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p>
<p><strong>删除操作时需要警惕</strong></p>
<p>为什么 3 没删掉？</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.begin(); it != a.end(); ++it)
    <span class="hljs-keyword">if</span> (*it == <span class="hljs-number">2</span> || *it == <span class="hljs-number">3</span>)
        a.erase(it);
<span class="hljs-comment">// a = [1, 3, 4]</span>
</div></code></pre>
<p>为啥 RE 了？</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = a.begin(); it != a.end(); ++it)
    <span class="hljs-keyword">if</span> (*it == <span class="hljs-number">4</span>)
        a.erase(it);
    <span class="hljs-comment">//删了4，前移一位，it = a.end(),然后自增后越界</span>
</div></code></pre>
<center><b>&#x5EFA;&#x8BAE;&#xFF1A;&#x5982;&#x65E0;&#x5FC5;&#x8981;&#xFF0C;&#x522B;&#x7528;&#x8FED;&#x4EE3;&#x5668;&#x64CD;&#x4F5C;&#x5BB9;&#x5668;&#x3002;&#xFF08;&#x904D;&#x5386;&#x4E0E;&#x8BBF;&#x95EE;&#x6CA1;&#x5173;&#x7CFB;&#xFF09;</b></center>
<h1 id="4-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">4 常用算法</h1>
<h2 id="41-%E5%86%85%E5%AE%B9%E6%80%BB%E8%A7%88">4.1 内容总览</h2>
<p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p>
<p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p>
<ul>
<li>
<p>算法库 Algorithm</p>
<ul>
<li><input type="checkbox" id="checkbox23"><label for="checkbox23"></label><code>count()</code></li>
<li><input type="checkbox" id="checkbox24"><label for="checkbox24"></label><code>find()</code></li>
<li><input type="checkbox" id="checkbox25"><label for="checkbox25"></label><code>fill()</code></li>
<li><input type="checkbox" id="checkbox26" checked="true"><label for="checkbox26"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li>
<li><input type="checkbox" id="checkbox27" checked="true"><label for="checkbox27"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li>
<li><input type="checkbox" id="checkbox28"><label for="checkbox28"></label><code>shuffle()</code> C++11</li>
<li><input type="checkbox" id="checkbox29" checked="true"><label for="checkbox29"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li>
<li><input type="checkbox" id="checkbox30" checked="true"><label for="checkbox30"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li>
<li><input type="checkbox" id="checkbox31" checked="true"><label for="checkbox31"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li>
<li><input type="checkbox" id="checkbox32" checked="true"><label for="checkbox32"></label><a href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> / <a href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li>
<li><input type="checkbox" id="checkbox33"><label for="checkbox33"></label><code>max_element()</code> / <code>min_element()</code></li>
<li><input type="checkbox" id="checkbox34"><label for="checkbox34"></label><code>prev_permutation()</code> / <code>next_permutation()</code></li>
</ul>
</li>
<li>
<p>数学函数 cmath</p>
<ul>
<li><input type="checkbox" id="checkbox35" checked="true"><label for="checkbox35"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li>
<li><input type="checkbox" id="checkbox36" checked="true"><label for="checkbox36"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li>
<li><input type="checkbox" id="checkbox37" checked="true"><label for="checkbox37"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> / <code>log10()</code> / <code>log2()</code></li>
<li><input type="checkbox" id="checkbox38" checked="true"><label for="checkbox38"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li>
<li><input type="checkbox" id="checkbox39" checked="true"><label for="checkbox39"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li>
<li><input type="checkbox" id="checkbox40"><label for="checkbox40"></label><code>sin()</code> / <code>cos()</code> / <code>tan()</code></li>
<li><input type="checkbox" id="checkbox41"><label for="checkbox41"></label><code>asin()</code> / <code>acos()</code> / <code>atan()</code></li>
<li><input type="checkbox" id="checkbox42"><label for="checkbox42"></label><code>sinh()</code> / <code>cosh()</code> / <code>tanh()</code></li>
<li><input type="checkbox" id="checkbox43"><label for="checkbox43"></label><code>asinh()</code> / <code>acosh()</code> / <code>atanh()</code> C++11</li>
<li><input type="checkbox" id="checkbox44" checked="true"><label for="checkbox44"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> / <a href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li>
<li><input type="checkbox" id="checkbox45" checked="true"><label for="checkbox45"></label><a href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li>
</ul>
</li>
<li>
<p>数值算法 numeric</p>
<ul>
<li><input type="checkbox" id="checkbox46"><label for="checkbox46"></label><code>iota()</code> C++11</li>
<li><input type="checkbox" id="checkbox47"><label for="checkbox47"></label><code>accumulate()</code></li>
<li><input type="checkbox" id="checkbox48" checked="true"><label for="checkbox48"></label><a href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li>
<li><input type="checkbox" id="checkbox49" checked="true"><label for="checkbox49"></label><a href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li>
</ul>
</li>
<li>
<p>伪随机数生成 random</p>
<ul>
<li><input type="checkbox" id="checkbox50"><label for="checkbox50"></label><code>mt19937</code></li>
<li><input type="checkbox" id="checkbox51"><label for="checkbox51"></label><code>random_device()</code></li>
</ul>
</li>
</ul>
<h2 id="42-swap">4.2 <code>swap()</code></h2>
<p>交换两个变量的值</p>
<p><strong>用法示例</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; class T &gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">( T&amp; a, T&amp; b )</span></span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;
swap(a, b);
<span class="hljs-comment">// now a = 1, b = 0</span>

<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
swap(arr[<span class="hljs-number">4</span>], arr[<span class="hljs-number">6</span>]);
<span class="hljs-comment">// now arr = {0, 1, 2, 3, 6, 5, 4, 7, 8, 9}</span>
</div></code></pre>
<p><strong>注意事项</strong></p>
<p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p>
<h2 id="43-sort">4.3 <code>sort()</code></h2>
<p>使用快速排序给一个可迭代对象排序</p>
<p><strong>用法示例</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; class RandomIt, class Compare &gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;
</div></code></pre>
<p>默认排序从小到大</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr{<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
sort(arr.begin(), arr.end());
<span class="hljs-comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span>
</div></code></pre>
<p>如果要从大到小，则需要传比较器进去。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr{<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
sort(arr.begin(), arr.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span>
</div></code></pre>
<p>如果需要完成特殊比较，则需要手写比较器。</p>
<p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\star$：</p>
<ul>
<li>若 $a\star b$，则比较器函数应当返回 <code>true</code></li>
<li>若 $a\not\star b$，则比较器函数应当返回 <code>false</code></li>
</ul>
<p>**注意：**如果 $a=b$，比较器函数必须返回 <code>false</code></p>
<p><strong>例：</strong> 要求对多个二元组进行如下排序：按照第二个数从小到大排；如果第二个数相同，则按照第一个数从大到小排；</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; b)</span>
</span>{
    <span class="hljs-keyword">if</span> (a.second != b.second)
        <span class="hljs-keyword">return</span> a.second &lt; b.second;
    <span class="hljs-keyword">return</span> a.first &gt; b.first;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; arr{{<span class="hljs-number">1</span>, <span class="hljs-number">9</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">9</span>}, {<span class="hljs-number">8</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>}};
	sort(arr.begin(), arr.end(), cmp);
    <span class="hljs-comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span>
}
</div></code></pre>
<h2 id="44-lowerbound--upperbound">4.4 <code>lower_bound()</code> / <code>upper_bound()</code></h2>
<p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p>
<ul>
<li><code>lower_bound()</code>: 寻找 $\geq x$ 的第一个元素的位置</li>
<li><code>upper_bound()</code>: 寻找 $&gt;x$ 的第一个元素的位置</li>
</ul>
<p>怎么找 $\leq x$ / $&lt; x$ 的第一个元素呢？</p>
<ul>
<li>$&gt;x$ 的第一个元素的前一个元素（如果有）便是 $\leq x$ 的第一个元素</li>
<li>$\geq x$ 的第一个元素的前一个元素（如果有）便是 $&lt;x$ 的第一个元素</li>
</ul>
<p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p>
<p><strong>示例</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; class ForwardIt, class T &gt;
ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-keyword">const</span> T&amp; value )</span></span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = lower_bound(arr.begin(), arr.end(), <span class="hljs-number">7</span>);
<span class="hljs-keyword">int</span> idx = it - arr.begin();
<span class="hljs-comment">// idx = 4</span>
</div></code></pre>
<p>我们通常写成一行：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>};
idx = lower_bound(arr.begin(), arr.end(), <span class="hljs-number">7</span>) - arr.begin(); <span class="hljs-comment">// 4</span>
idx = lower_bound(arr.begin(), arr.end(), <span class="hljs-number">8</span>) - arr.begin(); <span class="hljs-comment">// 4</span>
idx = upper_bound(arr.begin(), arr.end(), <span class="hljs-number">7</span>) - arr.begin(); <span class="hljs-comment">// 4</span>
idx = upper_bound(arr.begin(), arr.end(), <span class="hljs-number">8</span>) - arr.begin(); <span class="hljs-comment">// 5</span>
</div></code></pre>
<h2 id="45-reverse">4.5 <code>reverse()</code></h2>
<p>反转一个可迭代对象的元素顺序</p>
<p><strong>用法示例</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; class BidirIt &gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">( BidirIt first, BidirIt last )</span></span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
iota(arr.begin(), arr.end(), <span class="hljs-number">1</span>);
<span class="hljs-comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span>
reverse(arr.begin(), arr.end());
<span class="hljs-comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span>
</div></code></pre>
<h2 id="46-max--min">4.6 <code>max()</code> / <code>min()</code></h2>
<p>返回最大值 / 最小值的<strong>数值</strong></p>
<p><strong>用法示例</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> mx = max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
<span class="hljs-keyword">int</span> mn = min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span>
</div></code></pre>
<p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Before C++11</span>
<span class="hljs-keyword">int</span> mx = max(max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), max(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 4</span>
<span class="hljs-keyword">int</span> mn = min(min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), min(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// After C++11</span>
<span class="hljs-keyword">int</span> mx = max({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}); <span class="hljs-comment">// 4</span>
<span class="hljs-keyword">int</span> mn = min({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}); <span class="hljs-comment">// 1</span>
</div></code></pre>
<h2 id="47-unique">4.7 <code>unique()</code></h2>
<p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p>
<p>例如：$[1,1,4,5,1,4]\to[1,4,5,1,4,\underline?]$，下划线位置为返回的迭代器指向。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; class ForwardIt &gt;
ForwardIt <span class="hljs-title">unique</span><span class="hljs-params">( ForwardIt first, ForwardIt last )</span></span>;
</div></code></pre>
<p><strong>用法示例</strong></p>
<p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p>
<p>但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\to[1,2,4,5,\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.</p>
<p>最终，给 vector 去重的写法便是：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>};
sort(arr.begin(), arr.end());
<span class="hljs-comment">// sort 后  1 1 2 4 4 4 5</span>
<span class="hljs-comment">//unique后  1 2 4 5 指向-&gt;4 4 5 </span>
arr.erase(unique(arr.begin(), arr.end()), arr.end());
<span class="hljs-comment">//unique返回的是指向去重后容器中不重复序列末尾的下一个位置的迭代器。</span>
</div></code></pre>
<h2 id="48-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0">4.8 数学函数</h2>
<p>所有函数参数均支持 <code>int</code> / <code>long long</code> / <code>float</code> / <code>double</code> / <code>long double</code></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$f(x)=\lvert x\rvert$</td>
<td><code>abs(-1.0)</code></td>
</tr>
<tr>
<td>$f(x)=e^x$</td>
<td><code>exp(2)</code></td>
</tr>
<tr>
<td>$f(x)=\ln x$</td>
<td><code>log(3)</code></td>
</tr>
<tr>
<td>$f(x,y)=x^y$</td>
<td><code>pow(2, 3)</code></td>
</tr>
<tr>
<td>$f(x)=\sqrt x$</td>
<td><code>sqrt(2)</code></td>
</tr>
<tr>
<td>$f(x)=\lceil x\rceil$</td>
<td><code>ceil(2.1)</code></td>
</tr>
<tr>
<td>$f(x)=\lfloor x\rfloor$</td>
<td><code>floor(2.1)</code></td>
</tr>
<tr>
<td>$f(x)=\left&lt;x\right&gt;$</td>
<td><code>round(2.1)</code></td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<h2 id="%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E9%97%AE%E9%A2%98">浮点数误差问题</h2>
<p>在《算法竞赛入门经典》第二章例题2-1中提到，浮点数运算存在精度误差。例如，整数 1 可能因为误差变成 0.999999999，此时 <code>floor</code> 的结果会是 0 而非预期的 1。为避免这类问题，可以使用四舍五入：<code>floor(sqrt(x) + 0.5)</code>。</p>
<p><strong>更重要的是</strong>：当操作数都是整型时，应当避免使用浮点数运算，直接使用整数运算更加稳妥和精确，可以避免因浮点误差导致的 WA（Wrong Answer）。</p>
<blockquote>
<p>参考：https://codeforces.com/blog/entry/107717</p>
</blockquote>
<h3 id="%E6%8E%A8%E8%8D%90%E7%9A%84%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E5%86%99%E6%B3%95">推荐的整数运算写法</h3>
<h4 id="1-%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4%E9%99%A4%E6%B3%95-lfloorfracabrfloor">1. 向下取整除法 $\lfloor\frac{a}{b}\rfloor$</h4>
<ul>
<li>❌ 别用：<code>floor(1.0 * a / b)</code></li>
<li>✅ 要用：<code>a / b</code></li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">3</span>;
<span class="hljs-keyword">int</span> result = a / b;  <span class="hljs-comment">// 结果为 2</span>
</div></code></pre>
<h4 id="2-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%E9%99%A4%E6%B3%95-lceilfracabrceil">2. 向上取整除法 $\lceil\frac{a}{b}\rceil$</h4>
<ul>
<li>❌ 别用：<code>ceil(1.0 * a / b)</code></li>
<li>✅ 要用：<code>(a + b - 1) / b</code>（基于公式：$\lceil\frac{a}{b}\rceil=\lfloor\frac{a+b-1}{b}\rfloor$）</li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>, b = <span class="hljs-number">3</span>;
<span class="hljs-keyword">int</span> result = (a + b - <span class="hljs-number">1</span>) / b;  <span class="hljs-comment">// 结果为 3</span>
</div></code></pre>
<h4 id="3-%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4-lfloorsqrt-arfloor">3. 平方根向下取整 $\lfloor\sqrt a\rfloor$</h4>
<ul>
<li>❌ 别用：<code>(int) sqrt(a)</code></li>
<li>✅ 要用：<a href="https://oiwiki.com/basic/binary/">二分查找</a></li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 二分查找计算 floor(sqrt(n))</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
    <span class="hljs-keyword">while</span> (l &lt; r) {
        <span class="hljs-keyword">int</span> mid = l + (r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (mid &lt;= n / mid) l = mid;  <span class="hljs-comment">// 避免 mid * mid 溢出</span>
        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> l;
}
</div></code></pre>
<h4 id="4-%E6%95%B4%E6%95%B0%E5%B9%82%E8%BF%90%E7%AE%97-ab">4. 整数幂运算 $a^b$</h4>
<ul>
<li>❌ 别用：<code>pow(a, b)</code></li>
<li>✅ 要用：<a href="https://oiwiki.com/math/binary-exponentiation/">快速幂</a></li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 快速幂计算 a^b</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (b) {
        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res *= a;
        a *= a;
        b &gt;&gt;= <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<h4 id="5-%E4%BB%A52%E4%B8%BA%E5%BA%95%E7%9A%84%E5%AF%B9%E6%95%B0%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4-lfloorlog2-arfloor">5. 以2为底的对数向下取整 $\lfloor\log_2 a\rfloor$</h4>
<ul>
<li>❌ 别用：<code>log2(a)</code></li>
<li>✅ 要用：<code>__lg(a)</code> 或 <code>bit_width(a) - 1</code>（C++20）</li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">15</span>;
<span class="hljs-keyword">int</span> result = __lg(a);  <span class="hljs-comment">// 结果为 3，因为 log2(15) ≈ 3.9</span>
<span class="hljs-comment">// C++20: int result = std::bit_width((unsigned)a) - 1;</span>
</div></code></pre>
<h2 id="49-gcd--lcm">4.9 <code>gcd()</code> / <code>lcm()</code></h2>
<p>（C++17）返回最大公因数 / 最小公倍数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> x = gcd(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 4</span>
<span class="hljs-keyword">int</span> y = lcm(<span class="hljs-number">8</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">// 24</span>
</div></code></pre>
<p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p>
<p>当然，<code>gcd</code> / <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
    <span class="hljs-keyword">if</span> (!b)
        <span class="hljs-keyword">return</span> a;
    <span class="hljs-keyword">return</span> gcd(b, a % b);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
    <span class="hljs-keyword">return</span> a / gcd(a, b) * b;
}
</div></code></pre>
<hr>
<h1 id="5-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">5 其他常用容器</h1>
<p>本章节补充了一些在算法竞赛中也较为常用的容器，虽然使用频率不如前面章节的容器，但在特定场景下非常有用。</p>
<h2 id="51-%E6%95%B0%E7%BB%84-array">5.1 数组 <a href="https://zh.cppreference.com/w/cpp/container/array">array</a></h2>
<p><strong><code>#include &lt;array&gt;</code></strong></p>
<p>固定长度的顺序容器，在编译期就确定大小，性能接近原生数组，但提供了 STL 容器的接口。</p>
<h3 id="511-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.1.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>array&lt;类型, 长度&gt; arr</code></strong></p>
<p>注意：长度必须是编译期常量。</p>
<p>时间复杂度：$O(1)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr1;              <span class="hljs-comment">// 构造长度为5的int数组，未初始化</span>
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr2 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};  <span class="hljs-comment">// 构造并初始化前3个元素，后2个为0</span>
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr3{};            <span class="hljs-comment">// 构造并全部初始化为0</span>
</div></code></pre>
<h4 id="%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0">访问元素</h4>
<p><strong>中括号运算符 <code>[]</code></strong> 和 <strong><code>.at()</code></strong></p>
<p>时间复杂度：$O(1)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;     <span class="hljs-comment">// 1, 不检查越界</span>
<span class="hljs-built_in">cout</span> &lt;&lt; arr.at(<span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 1, 检查越界，越界会抛出异常</span>
</div></code></pre>
<h4 id="%E8%8E%B7%E5%8F%96%E9%A6%96%E5%B0%BE%E5%85%83%E7%B4%A0">获取首尾元素</h4>
<ul>
<li><strong><code>.front()</code></strong>：返回第一个元素</li>
<li><strong><code>.back()</code></strong>：返回最后一个元素</li>
</ul>
<p>时间复杂度：$O(1)$</p>
<h4 id="%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6">获取长度</h4>
<p><strong><code>.size()</code></strong></p>
<p>时间复杂度：$O(1)$</p>
<h4 id="%E5%A1%AB%E5%85%85">填充</h4>
<p><strong><code>.fill(值)</code></strong></p>
<p>将所有元素设置为指定值</p>
<p>时间复杂度：$O(n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr;
arr.fill(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 所有元素设为0</span>
</div></code></pre>
<h3 id="512-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.1.2 适用情形</h3>
<ul>
<li>长度在编译期已知且固定的场景</li>
<li>需要 STL 接口但又追求性能的场景</li>
<li>相比普通数组，array 可以作为函数返回值、支持赋值操作</li>
</ul>
<h3 id="513-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.1.3 注意事项</h3>
<h4 id="%E9%95%BF%E5%BA%A6%E5%BF%85%E9%A1%BB%E6%98%AF%E5%B8%B8%E9%87%8F">长度必须是常量</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, n&gt; arr;       <span class="hljs-comment">// 错误！n不是编译期常量</span>
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; arr;      <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;
<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, N&gt; arr;       <span class="hljs-comment">// 正确</span>
</div></code></pre>
<h4 id="%E4%B8%8D%E8%83%BD%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98%E5%A4%A7%E5%B0%8F">不能动态改变大小</h4>
<p>array 的大小在编译期确定，无法像 vector 那样动态增长。</p>
<h2 id="52-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-deque">5.2 双端队列 <a href="https://zh.cppreference.com/w/cpp/container/deque">deque</a></h2>
<p><strong><code>#include &lt;deque&gt;</code></strong></p>
<p>双端队列（double-ended queue），支持在头尾两端高效插入和删除的顺序容器。</p>
<h3 id="521-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.2.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>deque&lt;类型&gt; dq</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq;          <span class="hljs-comment">// 构造空双端队列</span>
<span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dq</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;      <span class="hljs-comment">// 构造长度为10的双端队列</span>
<span class="hljs-function"><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dq</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 构造长度为10，初值为1的双端队列</span>
</div></code></pre>
<h4 id="%E5%A4%B4%E5%B0%BE%E6%93%8D%E4%BD%9C">头尾操作</h4>
<ul>
<li><strong><code>.push_front(元素)</code></strong>：在头部插入元素</li>
<li><strong><code>.push_back(元素)</code></strong>：在尾部插入元素</li>
<li><strong><code>.pop_front()</code></strong>：删除头部元素</li>
<li><strong><code>.pop_back()</code></strong>：删除尾部元素</li>
<li><strong><code>.front()</code></strong>：访问头部元素</li>
<li><strong><code>.back()</code></strong>：访问尾部元素</li>
</ul>
<p>时间复杂度：均为 $O(1)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq;
dq.push_back(<span class="hljs-number">1</span>);   <span class="hljs-comment">// dq = [1]</span>
dq.push_front(<span class="hljs-number">2</span>);  <span class="hljs-comment">// dq = [2, 1]</span>
dq.push_back(<span class="hljs-number">3</span>);   <span class="hljs-comment">// dq = [2, 1, 3]</span>
<span class="hljs-keyword">int</span> x = dq.front(); <span class="hljs-comment">// x = 2</span>
dq.pop_front();    <span class="hljs-comment">// dq = [1, 3]</span>
</div></code></pre>
<h4 id="%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE">随机访问</h4>
<p><strong>中括号运算符 <code>[]</code></strong></p>
<p>时间复杂度：$O(1)$</p>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<ul>
<li><strong><code>.size()</code></strong>：获取长度</li>
<li><strong><code>.empty()</code></strong>：判空</li>
<li><strong><code>.clear()</code></strong>：清空</li>
</ul>
<h3 id="522-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.2.2 适用情形</h3>
<ul>
<li>需要在两端进行插入删除操作的场景</li>
<li>单调队列的实现</li>
<li>滑动窗口问题</li>
</ul>
<h3 id="523-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.2.3 注意事项</h3>
<h4 id="%E6%80%A7%E8%83%BD%E4%B8%8D%E5%A6%82-vector">性能不如 vector</h4>
<p>deque 虽然支持随机访问，但性能不如 vector，因为其内存不是完全连续的。如果只需要尾部操作，优先使用 vector。</p>
<h2 id="53-%E9%93%BE%E8%A1%A8-list">5.3 链表 <a href="https://zh.cppreference.com/w/cpp/container/list">list</a></h2>
<p><strong><code>#include &lt;list&gt;</code></strong></p>
<p>双向链表，支持在任意位置快速插入和删除，但不支持随机访问。</p>
<h3 id="531-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.3.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>list&lt;类型&gt; lst</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst;          <span class="hljs-comment">// 构造空链表</span>
<span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lst</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;      <span class="hljs-comment">// 构造10个元素的链表</span>
<span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lst</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>;   <span class="hljs-comment">// 构造10个元素，初值为1</span>
</div></code></pre>
<h4 id="%E5%A4%B4%E5%B0%BE%E6%93%8D%E4%BD%9C">头尾操作</h4>
<ul>
<li><strong><code>.push_front(元素)</code></strong>：在头部插入</li>
<li><strong><code>.push_back(元素)</code></strong>：在尾部插入</li>
<li><strong><code>.pop_front()</code></strong>：删除头部元素</li>
<li><strong><code>.pop_back()</code></strong>：删除尾部元素</li>
<li><strong><code>.front()</code></strong>：访问头部元素</li>
<li><strong><code>.back()</code></strong>：访问尾部元素</li>
</ul>
<p>时间复杂度：均为 $O(1)$</p>
<h4 id="%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">插入和删除</h4>
<ul>
<li><strong><code>.insert(迭代器, 元素)</code></strong>：在指定位置前插入</li>
<li><strong><code>.erase(迭代器)</code></strong>：删除指定位置元素</li>
</ul>
<p>时间复杂度：$O(1)$（需要先通过遍历找到位置）</p>
<h4 id="%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">其他操作</h4>
<ul>
<li><strong><code>.sort()</code></strong>：对链表排序</li>
<li><strong><code>.reverse()</code></strong>：反转链表</li>
<li><strong><code>.unique()</code></strong>：去除相邻重复元素</li>
<li><strong><code>.merge(另一个list)</code></strong>：合并两个有序链表</li>
</ul>
<h3 id="532-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.3.2 适用情形</h3>
<ul>
<li>频繁在中间位置插入删除的场景</li>
<li>不需要随机访问的场景</li>
<li>实际竞赛中很少使用，一般用 vector 或 deque 代替</li>
</ul>
<h3 id="533-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.3.3 注意事项</h3>
<h4 id="%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE">不支持随机访问</h4>
<pre class="hljs"><code><div><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">cout</span> &lt;&lt; lst[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 错误！不支持下标访问</span>
</div></code></pre>
<h4 id="%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80">性能开销</h4>
<p>链表的节点不连续，缓存性能差，在竞赛中一般不推荐使用。</p>
<h2 id="54-%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88-multiset">5.4 多重集合 <a href="https://zh.cppreference.com/w/cpp/container/multiset">multiset</a></h2>
<p><strong><code>#include &lt;set&gt;</code></strong></p>
<p>与 set 类似，但允许元素重复出现。底层原理是红黑树。</p>
<h3 id="541-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.4.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>multiset&lt;类型, 比较器&gt; mst</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; mst;               <span class="hljs-comment">// 从小到大</span>
<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; mst; <span class="hljs-comment">// 从大到小</span>
</div></code></pre>
<h4 id="%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">插入和删除</h4>
<ul>
<li><strong><code>.insert(元素)</code></strong>：插入元素（允许重复）</li>
<li><strong><code>.erase(元素)</code></strong>：删除<strong>所有</strong>等于该元素的值</li>
<li><strong><code>.erase(迭代器)</code></strong>：删除迭代器指向的单个元素</li>
</ul>
<p>时间复杂度：$O(\log n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; mst;
mst.insert(<span class="hljs-number">1</span>);  <span class="hljs-comment">// [1]</span>
mst.insert(<span class="hljs-number">1</span>);  <span class="hljs-comment">// [1, 1]</span>
mst.insert(<span class="hljs-number">2</span>);  <span class="hljs-comment">// [1, 1, 2]</span>
mst.erase(<span class="hljs-number">1</span>);   <span class="hljs-comment">// [2]，删除了所有的1</span>

<span class="hljs-comment">// 如果只想删除一个1：</span>
<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; mst = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
mst.erase(mst.find(<span class="hljs-number">1</span>));  <span class="hljs-comment">// [1, 2]，只删除一个1</span>
</div></code></pre>
<h4 id="%E6%9F%A5%E6%89%BE%E5%92%8C%E8%AE%A1%E6%95%B0">查找和计数</h4>
<ul>
<li><strong><code>.find(元素)</code></strong>：返回任意一个等于该元素的迭代器</li>
<li><strong><code>.count(元素)</code></strong>：返回元素出现的次数</li>
</ul>
<p>时间复杂度：$O(\log n)$（count 为 $O(\log n + k)$，$k$ 为元素个数）</p>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<ul>
<li><strong><code>.size()</code></strong>、<strong><code>.empty()</code></strong>、<strong><code>.clear()</code></strong></li>
</ul>
<h3 id="542-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.4.2 适用情形</h3>
<ul>
<li>需要维护有序序列且允许重复的场景</li>
<li>动态维护中位数</li>
<li>对顶堆的实现</li>
</ul>
<h3 id="543-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.4.3 注意事项</h3>
<h4 id="%E5%88%A0%E9%99%A4%E6%97%B6%E6%B3%A8%E6%84%8F%E6%98%AF%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E8%BF%98%E6%98%AF%E5%8D%95%E4%B8%AA">删除时注意是删除所有还是单个</h4>
<pre class="hljs"><code><div><span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; mst = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
mst.erase(<span class="hljs-number">1</span>);              <span class="hljs-comment">// 删除所有1，结果：[2]</span>
mst.erase(mst.find(<span class="hljs-number">1</span>));    <span class="hljs-comment">// 只删除一个1，结果：[1, 1, 2]</span>
</div></code></pre>
<h2 id="55-%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84-multimap">5.5 多重映射 <a href="https://zh.cppreference.com/w/cpp/container/multimap">multimap</a></h2>
<p><strong><code>#include &lt;map&gt;</code></strong></p>
<p>与 map 类似，但允许键重复出现。底层原理是红黑树。</p>
<h3 id="551-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.5.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>multimap&lt;键类型, 值类型, 比较器&gt; mmp</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mmp;               <span class="hljs-comment">// 键从小到大</span>
<span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; mmp; <span class="hljs-comment">// 键从大到小</span>
</div></code></pre>
<h4 id="%E6%8F%92%E5%85%A5">插入</h4>
<ul>
<li><strong><code>.insert({键, 值})</code></strong> 或 <strong><code>.insert(make_pair(键, 值))</code></strong></li>
</ul>
<p>时间复杂度：$O(\log n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mmp;
mmp.insert({<span class="hljs-number">1</span>, <span class="hljs-number">100</span>});
mmp.insert({<span class="hljs-number">1</span>, <span class="hljs-number">200</span>});  <span class="hljs-comment">// 允许键重复</span>
mmp.insert({<span class="hljs-number">2</span>, <span class="hljs-number">300</span>});
</div></code></pre>
<h4 id="%E6%9F%A5%E6%89%BE">查找</h4>
<ul>
<li><strong><code>.find(键)</code></strong>：返回任意一个该键的迭代器</li>
<li><strong><code>.count(键)</code></strong>：返回该键出现的次数</li>
<li><strong><code>.equal_range(键)</code></strong>：返回包含所有该键元素的迭代器范围</li>
</ul>
<p>时间复杂度：$O(\log n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mmp = {{<span class="hljs-number">1</span>, <span class="hljs-number">100</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">200</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">300</span>}};
<span class="hljs-built_in">cout</span> &lt;&lt; mmp.count(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">auto</span> range = mmp.equal_range(<span class="hljs-number">1</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range.first; it != range.second; ++it)
    <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 输出 100 200</span>
</div></code></pre>
<h4 id="%E5%88%A0%E9%99%A4">删除</h4>
<ul>
<li><strong><code>.erase(键)</code></strong>：删除所有该键的元素</li>
<li><strong><code>.erase(迭代器)</code></strong>：删除单个元素</li>
</ul>
<p>时间复杂度：$O(\log n)$</p>
<h3 id="552-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.5.2 适用情形</h3>
<ul>
<li>需要一对多映射的场景</li>
<li>实际竞赛中较少使用，一般用 <code>map&lt;键, vector&lt;值&gt;&gt;</code> 代替</li>
</ul>
<h3 id="553-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.5.3 注意事项</h3>
<h4 id="%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%AE%BF%E9%97%AE">不能使用中括号访问</h4>
<pre class="hljs"><code><div><span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mmp;
mmp[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 错误！multimap不支持[]运算符</span>
</div></code></pre>
<h2 id="56-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88-unorderedset">5.6 无序集合 <a href="https://zh.cppreference.com/w/cpp/container/unordered_set">unordered_set</a></h2>
<p><strong><code>#include &lt;unordered_set&gt;</code></strong></p>
<p>基于哈希表实现的集合，元素无序但查找速度快。</p>
<h3 id="561-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.6.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>unordered_set&lt;类型&gt; ust</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; ust;
</div></code></pre>
<h4 id="%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">插入和删除</h4>
<ul>
<li><strong><code>.insert(元素)</code></strong>：插入元素</li>
<li><strong><code>.erase(元素)</code></strong>：删除元素</li>
</ul>
<p>平均时间复杂度：$O(1)$，最坏 $O(n)$</p>
<h4 id="%E6%9F%A5%E6%89%BE">查找</h4>
<ul>
<li><strong><code>.find(元素)</code></strong>：返回元素迭代器</li>
<li><strong><code>.count(元素)</code></strong>：判断元素是否存在（返回0或1）</li>
</ul>
<p>平均时间复杂度：$O(1)$，最坏 $O(n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; ust = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-keyword">if</span> (ust.count(<span class="hljs-number">3</span>))  <span class="hljs-comment">// 判断3是否存在</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"exists"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<ul>
<li><strong><code>.size()</code></strong>、<strong><code>.empty()</code></strong>、<strong><code>.clear()</code></strong></li>
</ul>
<h3 id="562-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.6.2 适用情形</h3>
<ul>
<li>只需要判断元素是否存在，不需要有序性</li>
<li>对查找性能要求高的场景</li>
<li>元素去重但不需要排序</li>
</ul>
<h3 id="563-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.6.3 注意事项</h3>
<h4 id="%E5%85%83%E7%B4%A0%E6%97%A0%E5%BA%8F">元素无序</h4>
<p>unordered_set 的元素是无序的，遍历时的顺序不确定。</p>
<h4 id="%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E6%80%A7%E8%83%BD%E9%80%80%E5%8C%96">最坏情况性能退化</h4>
<p>当哈希冲突严重时，时间复杂度会退化到 $O(n)$。竞赛中如果被卡哈希，可以使用 set 代替。</p>
<h4 id="%E4%B8%8D%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">不支持自定义类型</h4>
<p>对于自定义类型，需要提供哈希函数，比较麻烦。</p>
<h2 id="57-%E6%97%A0%E5%BA%8F%E6%98%A0%E5%B0%84-unorderedmap">5.7 无序映射 <a href="https://zh.cppreference.com/w/cpp/container/unordered_map">unordered_map</a></h2>
<p><strong><code>#include &lt;unordered_map&gt;</code></strong></p>
<p>基于哈希表实现的键值对容器，键无序但查找速度快。</p>
<h3 id="571-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.7.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>unordered_map&lt;键类型, 值类型&gt; ump</code></strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; ump;
<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; ump;  <span class="hljs-comment">// 常用于字符串映射</span>
</div></code></pre>
<h4 id="%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">增删改查</h4>
<ul>
<li><strong>中括号 <code>[]</code></strong>：访问或插入</li>
<li><strong><code>.insert({键, 值})</code></strong>：插入</li>
<li><strong><code>.erase(键)</code></strong>：删除</li>
<li><strong><code>.find(键)</code></strong>：查找</li>
<li><strong><code>.count(键)</code></strong>：判断键是否存在</li>
</ul>
<p>平均时间复杂度：$O(1)$，最坏 $O(n)$</p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; ump;
ump[<span class="hljs-string">"apple"</span>] = <span class="hljs-number">5</span>;
ump[<span class="hljs-string">"banana"</span>] = <span class="hljs-number">3</span>;

<span class="hljs-keyword">if</span> (ump.count(<span class="hljs-string">"apple"</span>))
    <span class="hljs-built_in">cout</span> &lt;&lt; ump[<span class="hljs-string">"apple"</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 5</span>
</div></code></pre>
<h4 id="%E5%85%B6%E4%BB%96">其他</h4>
<ul>
<li><strong><code>.size()</code></strong>、<strong><code>.empty()</code></strong>、<strong><code>.clear()</code></strong></li>
</ul>
<h3 id="572-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.7.2 适用情形</h3>
<ul>
<li>只需要键值映射，不需要键的有序性</li>
<li>对查找性能要求高的场景</li>
<li>字符串哈希、计数等场景</li>
</ul>
<h3 id="573-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.7.3 注意事项</h3>
<h4 id="%E9%94%AE%E6%97%A0%E5%BA%8F">键无序</h4>
<p>遍历时键的顺序不确定。</p>
<h4 id="%E5%8F%AF%E8%83%BD%E8%A2%AB%E5%8D%A1%E5%93%88%E5%B8%8C">可能被卡哈希</h4>
<p>竞赛中如果被卡哈希，使用 map 代替或自定义哈希函数。</p>
<h4 id="%E4%B8%AD%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8">中括号的副作用</h4>
<p>与 map 相同，使用 <code>[]</code> 访问不存在的键会创建该键。</p>
<h2 id="58-%E6%97%A0%E5%BA%8F%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88-unorderedmultiset">5.8 无序多重集合 <a href="https://zh.cppreference.com/w/cpp/container/unordered_multiset">unordered_multiset</a></h2>
<p><strong><code>#include &lt;unordered_set&gt;</code></strong></p>
<p>基于哈希表的 multiset，允许元素重复且无序。</p>
<h3 id="581-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.8.1 常用方法</h3>
<p>与 multiset 类似，但元素无序，操作的平均时间复杂度为 $O(1)$。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_multiset</span>&lt;<span class="hljs-keyword">int</span>&gt; umst;
umst.insert(<span class="hljs-number">1</span>);
umst.insert(<span class="hljs-number">1</span>);
umst.insert(<span class="hljs-number">2</span>);
<span class="hljs-built_in">cout</span> &lt;&lt; umst.count(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 2</span>
</div></code></pre>
<h3 id="582-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.8.2 适用情形</h3>
<p>需要允许重复元素，且不需要有序性，追求查找性能。</p>
<h3 id="583-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.8.3 注意事项</h3>
<p>实际竞赛中很少使用，一般用 unordered_map 配合计数实现。</p>
<h2 id="59-%E6%97%A0%E5%BA%8F%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84-unorderedmultimap">5.9 无序多重映射 <a href="https://zh.cppreference.com/w/cpp/container/unordered_multimap">unordered_multimap</a></h2>
<p><strong><code>#include &lt;unordered_map&gt;</code></strong></p>
<p>基于哈希表的 multimap，允许键重复且无序。</p>
<h3 id="591-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.9.1 常用方法</h3>
<p>与 multimap 类似，但键无序，操作的平均时间复杂度为 $O(1)$。</p>
<pre class="hljs"><code><div><span class="hljs-built_in">unordered_multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; ummp;
ummp.insert({<span class="hljs-number">1</span>, <span class="hljs-number">100</span>});
ummp.insert({<span class="hljs-number">1</span>, <span class="hljs-number">200</span>});
<span class="hljs-built_in">cout</span> &lt;&lt; ummp.count(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 2</span>
</div></code></pre>
<h3 id="592-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.9.2 适用情形</h3>
<p>需要一对多映射，且不需要键的有序性。</p>
<h3 id="593-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.9.3 注意事项</h3>
<p>实际竞赛中很少使用，一般用 <code>unordered_map&lt;键, vector&lt;值&gt;&gt;</code> 代替。</p>
<h2 id="510-%E5%85%83%E7%BB%84-tuple">5.10 元组 <a href="https://zh.cppreference.com/w/cpp/utility/tuple">tuple</a></h2>
<p><strong><code>#include &lt;tuple&gt;</code></strong></p>
<p>可以存储任意数量、任意类型元素的容器，是 pair 的扩展版本。</p>
<h3 id="5101-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.10.1 常用方法</h3>
<h4 id="%E6%9E%84%E9%80%A0">构造</h4>
<p><strong><code>tuple&lt;类型1, 类型2, ...&gt; tup</code></strong></p>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t1;
tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; t2;
</div></code></pre>
<h4 id="%E8%B5%8B%E5%80%BC">赋值</h4>
<p>老式写法：</p>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t = make_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"hello"</span>);
</div></code></pre>
<p>列表构造（C++11）：</p>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t = {<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"hello"</span>};
</div></code></pre>
<h4 id="%E5%8F%96%E5%80%BC">取值</h4>
<p>使用 <code>get&lt;索引&gt;(tuple)</code> 获取元素（索引从0开始）：</p>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t = {<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"hello"</span>};
<span class="hljs-keyword">int</span> a = get&lt;<span class="hljs-number">0</span>&gt;(t);        <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">double</span> b = get&lt;<span class="hljs-number">1</span>&gt;(t);     <span class="hljs-comment">// 3.14</span>
<span class="hljs-built_in">string</span> c = get&lt;<span class="hljs-number">2</span>&gt;(t);     <span class="hljs-comment">// "hello"</span>
</div></code></pre>
<p>结构化绑定（C++17）：</p>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t = {<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">"hello"</span>};
<span class="hljs-keyword">auto</span> [a, b, c] = t;
<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">' '</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 1 3.14 hello</span>
</div></code></pre>
<h4 id="%E8%8E%B7%E5%8F%96%E5%85%83%E7%BB%84%E5%A4%A7%E5%B0%8F">获取元组大小</h4>
<pre class="hljs"><code><div>tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-built_in">string</span>&gt; t;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> size = tuple_size&lt;<span class="hljs-keyword">decltype</span>(t)&gt;::value;  <span class="hljs-comment">// 3</span>
</div></code></pre>
<h3 id="5102-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2">5.10.2 适用情形</h3>
<ul>
<li>需要返回多个值的函数</li>
<li>存储三元组、四元组等多元数据</li>
<li>在 map 中使用复合键：<code>map&lt;tuple&lt;int, int, int&gt;, int&gt;</code></li>
</ul>
<h3 id="5103-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.10.3 注意事项</h3>
<h4 id="%E8%AE%BF%E9%97%AE%E8%AF%AD%E6%B3%95%E8%BE%83%E7%B9%81%E7%90%90">访问语法较繁琐</h4>
<p>相比 pair 的 <code>.first</code> 和 <code>.second</code>，tuple 的 <code>get&lt;0&gt;()</code> 语法较为冗长，建议配合 C++17 的结构化绑定使用。</p>
<h4 id="%E5%8F%AF%E8%AF%BB%E6%80%A7%E9%97%AE%E9%A2%98">可读性问题</h4>
<p>对于元素较多的 tuple，建议定义结构体以提高代码可读性：</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 不推荐</span>
tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-keyword">double</span>&gt; student;

<span class="hljs-comment">// 推荐</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> {</span>
    <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">double</span> score;
};
</div></code></pre>
<h1 id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</h1>
<h2 id="%E6%A8%A1%E7%89%88%E9%A2%98">模版题</h2>
<p>题意：
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-comment">// lower_bound 返回最小的满足 nums[i] &gt;= target 的下标 i</span>
    <span class="hljs-comment">// 如果数组为空，或者所有数都 &lt; target，则返回 nums.size()</span>
    <span class="hljs-comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-keyword">int</span>) nums.size() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 闭区间 [left, right]</span>
        <span class="hljs-keyword">while</span> (left &lt;= right) { <span class="hljs-comment">// 区间不为空</span>
            <span class="hljs-comment">// 循环不变量：</span>
            <span class="hljs-comment">// nums[left-1] &lt; target</span>
            <span class="hljs-comment">// nums[right+1] &gt;= target</span>
            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) {
                right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span>
            } <span class="hljs-keyword">else</span> {
                left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span>
            }
        }
        <span class="hljs-comment">// 循环结束后 left = right+1</span>
        <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span>
        <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span>
        <span class="hljs-keyword">return</span> left;
    }

    <span class="hljs-comment">// 示例：在数组 [1, 3, 3, 5, 7, 9] 中查找第一个 &gt;= 5 的位置</span>
    <span class="hljs-comment">// 索引：          0  1  2  3  4  5</span>
    <span class="hljs-comment">// 数组：         [1, 3, 3, 5, 7, 9]   target = 5</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 初始状态：</span>
    <span class="hljs-comment">//                 ↓              ↓</span>
    <span class="hljs-comment">//                [1, 3, 3, 5, 7, 9]</span>
    <span class="hljs-comment">//                 L              R</span>
    <span class="hljs-comment">//                left=0, right=5</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 第 1 次循环：</span>
    <span class="hljs-comment">//                 ↓     ↓        ↓</span>
    <span class="hljs-comment">//                [1, 3, 3, 5, 7, 9]</span>
    <span class="hljs-comment">//                 L     M        R</span>
    <span class="hljs-comment">//                          L‘</span>
    <span class="hljs-comment">//                left=0, mid=2, right=5</span>
    <span class="hljs-comment">//                nums[2]=3 &lt; 5，执行 left = mid + 1</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 第 2 次循环：</span>
    <span class="hljs-comment">//                          ↓  ↓  ↓</span>
    <span class="hljs-comment">//                [1, 3, 3, 5, 7, 9]</span>
    <span class="hljs-comment">//                          L  M  R</span>
    <span class="hljs-comment">//                          R’</span>
    <span class="hljs-comment">//                left=3, 取中点后mid=4, right=5</span>
    <span class="hljs-comment">//                nums[4]=7 &gt;= 5，执行 right = mid - 1</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 第 3 次循环：</span>
    <span class="hljs-comment">//                         ↓↓↓</span>
    <span class="hljs-comment">//                [1, 3, 3, 5, 7, 9]</span>
    <span class="hljs-comment">//                         LRM</span>
    <span class="hljs-comment">//                       R‘</span>
    <span class="hljs-comment">//                left=3, mid=3, right=3</span>
    <span class="hljs-comment">//                nums[3]=5 &gt;= 5，执行 right = mid - 1</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 循环结束：</span>
    <span class="hljs-comment">//                       ↓  ↓↓</span>
    <span class="hljs-comment">//                [1, 3, 3, 5, 7, 9]</span>
    <span class="hljs-comment">//                       R  LM</span>
    <span class="hljs-comment">//                left=3, right=2 (left &gt; right，退出循环)</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// 返回 left = 3，即第一个 &gt;= 5 的元素下标为 3</span>
    }

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> start = lower_bound(nums, target);
        <span class="hljs-keyword">if</span> (start == nums.size() || nums[start] != target) {
            <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>}; <span class="hljs-comment">// nums 中没有 target</span>
        }
        <span class="hljs-comment">// 如果 start 存在，那么 end 必定存在</span>
        <span class="hljs-keyword">int</span> end = lower_bound(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> {start, end};
    }
};
</div></code></pre>
<table>
<thead>
<tr>
<th>需求</th>
<th>写法</th>
<th>如果不存在</th>
</tr>
</thead>
<tbody>
<tr>
<td>≥x 的第一个元素的下标</td>
<td>lowerBound(nums, x)</td>
<td>结果为 n</td>
</tr>
<tr>
<td>&gt;x 的第一个元素的下标</td>
<td>lowerBound(nums, x+1)</td>
<td>结果为 n</td>
</tr>
<tr>
<td>&lt;x 的最后一个元素的下标</td>
<td>lowerBound(nums, x) − 1</td>
<td>结果为 -1</td>
</tr>
<tr>
<td>≤x 的最后一个元素的下标</td>
<td>lowerBound(nums, x+1) − 1</td>
<td>结果为 -1</td>
</tr>
</tbody>
</table>
<h3 id="%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%83%85%E5%86%B5%E7%9A%84%E8%A7%A3%E9%87%8A">不存在情况的解释</h3>
<h4 id="%E7%A4%BA%E4%BE%8B-1%E6%9F%A5%E6%89%BE-%E2%89%A5x-%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%86%E6%89%80%E6%9C%89%E6%95%B0%E9%83%BD--x">示例 1：查找 ≥x 的第一个元素，但所有数都 &lt; x</h4>
<pre class="hljs"><code><div>数组：[1, 3, 3, 5, 7, 9]   target = 10
索引： 0  1  2  3  4  5

初始状态：
                ↓              ↓
               [1, 3, 3, 5, 7, 9]
                L              R
               left=0, right=5

第 1 次循环：
                ↓     ↓        ↓
               [1, 3, 3, 5, 7, 9]
                L     M        R
                         L'
               left=0, mid=2, right=5
               nums[2]=3 &lt; 10，执行 left = mid + 1

第 2 次循环：
                         ↓  ↓  ↓
               [1, 3, 3, 5, 7, 9]
                         L  M  R
                               L'
               left=3, mid=4, right=5
               nums[4]=7 &lt; 10，执行 left = mid + 1

第 3 次循环：
                               ↓↓
               [1, 3, 3, 5, 7, 9]
                               LR
                               M
               left=5, mid=5, right=5
               nums[5]=9 &lt; 10，执行 left = mid + 1

循环结束：
                               ↓  ↓
               [1, 3, 3, 5, 7, 9] |
                               R  L
               left=6, right=5 (left &gt; right，退出循环)

返回 left = 6 = nums.size()
因为所有数都 &lt; 10，所以不存在 ≥10 的元素，返回 n 表示&quot;超出数组范围&quot;
</div></code></pre>
<h4 id="%E7%A4%BA%E4%BE%8B-2%E6%9F%A5%E6%89%BE-x-%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%86%E6%89%80%E6%9C%89%E6%95%B0%E9%83%BD-%E2%89%A5-x">示例 2：查找 &lt;x 的最后一个元素，但所有数都 ≥ x</h4>
<pre class="hljs"><code><div>数组：[1, 3, 3, 5, 7, 9]   target = 1
索引： 0  1  2  3  4  5

查找 &lt;1 的最后一个元素 = lowerBound(nums, 1) - 1

先执行 lowerBound(nums, 1)：

初始状态：
                ↓              ↓
               [1, 3, 3, 5, 7, 9]
                L              R
               left=0, right=5

第 1 次循环：
                ↓     ↓        ↓
               [1, 3, 3, 5, 7, 9]
                L     M        R
                R'
               left=0, mid=2, right=5
               nums[2]=3 &gt;= 1，执行 right = mid - 1

第 2 次循环：
                ↓  ↓
               [1, 3, 3, 5, 7, 9]
                L  R
                M
               left=0, mid=0, right=1
               nums[0]=1 &gt;= 1，执行 right = mid - 1

循环结束：
             ↓  ↓
            |[1, 3, 3, 5, 7, 9]
             R  L
            left=0, right=-1 (left &gt; right，退出循环)

lowerBound 返回 left = 0
结果 = 0 - 1 = -1
因为所有数都 &gt;= 1，所以不存在 &lt;1 的元素，返回 -1 表示&quot;不存在&quot;
</div></code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>当查找 <strong>≥x</strong> 或 <strong>&gt;x</strong> 时，如果不存在，left 会一直右移直到超出数组，返回 <strong>n</strong></li>
<li>当查找 <strong>&lt;x</strong> 或 <strong>≤x</strong> 时，如果不存在，lowerBound 返回 0，减 1 后得到 <strong>-1</strong></li>
</ul>
<h2 id="vector-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AF%E5%8C%BA"><code>vector</code> 初始化误区</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// ❌ 错误：空vector不能直接用[]赋值</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; vec;
vec[<span class="hljs-number">0</span>] = <span class="hljs-number">3.14</span>;  <span class="hljs-comment">// 运行时错误！</span>

<span class="hljs-comment">// ✅ 方法1: 指定大小</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;
vec[<span class="hljs-number">0</span>] = <span class="hljs-number">3.14</span>;  <span class="hljs-comment">// 正确</span>

<span class="hljs-comment">// ✅ 方法2: push_back</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; vec;
vec.push_back(<span class="hljs-number">3.14</span>);  <span class="hljs-comment">// 正确</span>

<span class="hljs-comment">// ✅ 方法3: 初始化列表</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; vec = {<span class="hljs-number">3.14</span>, <span class="hljs-number">2.71</span>};  <span class="hljs-comment">// 正确</span>
</div></code></pre>
<h3 id="2413-%E6%9C%80%E5%B0%8F%E5%81%B6%E5%80%8D%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/smallest-even-multiple/solutions/1831561/yi-xing-gong-shi-by-endlesscheng-ixss/?envType=study-plan-v2&amp;envId=primers-list">2413. 最小偶倍数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>我就直接用循环模拟了</li>
<li>我居然没想到，n为奇答案就是2*n，n为偶答案就是n；但是这个优雅的写法我还是写不出来哈</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">smallestEvenMultiple</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">return</span> (n % <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) * n;
    }
};
</div></code></pre>
<h2 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</h2>
<p>在 C++ 中，有三个主要的位运算符，我来详细解释一下：</p>
<p>三个主要位运算符：</p>
<h3 id="1-%E6%8C%89%E4%BD%8D%E4%B8%8E-and">1. <strong>按位与 (AND)</strong> - <code>&amp;</code></h3>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 二进制: 0101</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 二进制: 0011</span>
<span class="hljs-keyword">int</span> result = a &amp; b;  <span class="hljs-comment">// 结果: 0001 (十进制 1)</span>
</div></code></pre>
<h3 id="2-%E6%8C%89%E4%BD%8D%E6%88%96-or">2. <strong>按位或 (OR)</strong> - <code>|</code></h3>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 二进制: 0101</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 二进制: 0011</span>
<span class="hljs-keyword">int</span> result = a | b;  <span class="hljs-comment">// 结果: 0111 (十进制 7)</span>
</div></code></pre>
<h3 id="3-%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96-xor">3. <strong>按位异或 (XOR)</strong> - <code>^</code></h3>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 二进制: 0101</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 二进制: 0011</span>
<span class="hljs-keyword">int</span> result = a ^ b;  <span class="hljs-comment">// 结果: 0110 (十进制 6)</span>
</div></code></pre>
<h2 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8">位运算的简单应用：</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 检查奇偶性</span>
<span class="hljs-keyword">bool</span> isEven = (num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;  <span class="hljs-comment">// 与1进行AND运算</span>

<span class="hljs-comment">// 乘以2的幂次</span>
<span class="hljs-keyword">int</span> multiplyBy8 = num &lt;&lt; <span class="hljs-number">3</span>;    <span class="hljs-comment">// 左移3位相当于乘以8</span>

<span class="hljs-comment">// 除以2的幂次</span>
<span class="hljs-keyword">int</span> divideBy4 = num &gt;&gt; <span class="hljs-number">2</span>;      <span class="hljs-comment">// 右移2位相当于除以4</span>
</div></code></pre>
<h3 id="1512-%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/number-of-good-pairs/description/?envType=study-plan-v2&amp;envId=primers-list">1512. 好数对的数目</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，则称这组数字是一个 好数对 。</p>
<p>返回好数对的数目。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>我的思路直接是二重循环。。O(n^2)复杂度</li>
<li>哈希表，O（n）复杂度</li>
<li><input type="checkbox" id="checkbox52" checked="true"><label for="checkbox52">中的 x 第一次出现时：会自动创建键 x，值会被初始化为 0（对于 int 类型）</label></li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) { <span class="hljs-comment">// x = nums[j]</span>
            <span class="hljs-comment">// 此时 cnt[x] 表示之前遍历过的 x 的个数，加到 ans 中</span>
            <span class="hljs-comment">// 如果先执行 cnt[x]++，再执行 ans += cnt[x]，就把 i=j 这种情况也统计进来了，算出的答案会偏大</span>
            ans += cnt[x];
            cnt[x]++;
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/count-good-triplets/description/?envType=study-plan-v2&amp;envId=primers-list">1534. 统计好三元组</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。</p>
<p>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。</p>
<ul>
<li>0 &lt;= i &lt; j &lt; k &lt; arr.length</li>
<li>|arr[i] - arr[j]| &lt;= a</li>
<li>|arr[j] - arr[k]| &lt;= b</li>
<li>|arr[i] - arr[k]| &lt;= c</li>
</ul>
<p>其中 |x| 表示 x 的绝对值。</p>
<p>返回 好三元组的数量 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>我还是只会暴力O(n^3)复杂度，学一下<a href="https://oiwiki.com/basic/prefix-sum/">前缀和</a></li>
<li>前缀和定义为：( S_i = \sum_{j=1}^{i} a_j )</li>
<li>递推关系式为：( S_i = S_{i-1} + a_i )</li>
<li>计算区间 ([l, r]) 的和，只需用前缀和相减：( S([l, r]) = S_r - S_{l-1} )</li>
<li>通过 (O(n)) 时间预处理前缀和数组，可以将单次区间和查询的复杂度降至 (O(1))。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodTriplets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>{
        <span class="hljs-keyword">int</span> n = arr.size(), mx = ranges::max(arr);
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(mx+ <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">//表示值v出现次数</span>
        <span class="hljs-comment">// prefix[v] 表示值 ≤ v 的元素个数</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(mx + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
            <span class="hljs-comment">// 对于每个 j，枚举所有 k &gt; j</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; k++) {
                <span class="hljs-comment">// 先检查 |arr[j] - arr[k]| &lt;= b</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(arr[j] - arr[k]) &lt;= b) {
                    <span class="hljs-comment">// 确定 i 的取值范围</span>
                    <span class="hljs-keyword">int</span> left = max({arr[j] - a, arr[k] - c, <span class="hljs-number">0</span>});
                    <span class="hljs-keyword">int</span> right = min({arr[j] + a, arr[k] + c, mx});
                    
                    <span class="hljs-comment">// 如果范围有效，计算范围内有多少个元素</span>
                    <span class="hljs-keyword">if</span> (left &lt;= right) {
                        <span class="hljs-comment">// prefix[right+1] - prefix[left] 就是值在 [left, right] 内的元素个数</span>
                        ans += prefix[right + <span class="hljs-number">1</span>] - prefix[left];
                    }
                }
            }
            
            <span class="hljs-comment">// 处理完当前 j 的所有 k 后，把 arr[j] 加入统计</span>
            <span class="hljs-comment">// 这样保证后续的 j 能看到当前 j 的元素</span>
            count[arr[j]]++;
            
            <span class="hljs-comment">// 更新前缀和数组</span>
            prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= mx + <span class="hljs-number">1</span>; v++) {
                prefix[v] = prefix[v - <span class="hljs-number">1</span>] + count[v - <span class="hljs-number">1</span>];
            }
        }
        
        <span class="hljs-keyword">return</span> ans;
    }            
};

</div></code></pre>
<h3 id="258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/add-digits/description/?envType=study-plan-v2&amp;envId=primers-list">258. 各位相加</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>还是只会用循环，来看看O（1）做法：</li>
<li>比如 num = 678，计算过程为：<code>678 -&gt; 21 -&gt; 3</code></li>
<li>本质上是求模9的同余数。</li>
<li>如果 num == 0，返回 0；</li>
<li>如果 num % 9 == 0，返回 9；</li>
<li>否则返回 num % 9。</li>
<li>公式：<code>(num - 1) % 9 + 1</code></li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 循环版</span>
<span class="hljs-comment">// 略</span>

<span class="hljs-comment">// O(1)版</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">return</span> (num - <span class="hljs-number">1</span>) % <span class="hljs-number">9</span> + <span class="hljs-number">1</span>;
    }
};
</div></code></pre>
<h3 id="231-2-%E7%9A%84%E5%B9%82-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/power-of-two/description/?envType=study-plan-v2&amp;envId=primers-list">231. 2 的幂</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>我用循环，当n很大的时候，超时，找数学规律，没找出来。</li>
<li>位运算：如果 n 是 2 的幂，那么 <code>n &amp; (n-1)</code> 一定等于 0。</li>
<li>注意优先级。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;
        <span class="hljs-comment">//注意这个括号，优先级：算术 &gt; 移位 &gt; 关系 &gt; 相等 &gt; 位运算 &gt; 逻辑 &gt; 赋值</span>
    }
};
</div></code></pre>
<h3 id="326-3-%E7%9A%84%E5%B9%82-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/power-of-three/description/?envType=study-plan-v2&amp;envId=primers-list">326. 3 的幂</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>循环法：已知 $2^{31} \approx 2.1 \times 10^9$，大约 $x$ 最大约等于20，保险起见可以枚举到30。</li>
<li>数论法：<code>while (n % 3 == 0) n /= 3; return n == 1;</code></li>
<li>递归法</li>
<li>整数限制法：在 32 位有符号整数范围内，最大的 3 的幂是 $3^{19} = 1162261467$，判断是否能整除。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-comment">//计算出大概是20左右，可以测试输出，刚好报错的那个数前面就是了</span>
        <span class="hljs-comment">// 在 32 位有符号整数范围内，最大的 3 的幂是 3^19 = 1162261467</span>
        <span class="hljs-comment">// 如果 n 是 3 的幂，那么 1162261467 一定能被 n 整除</span>
        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span> % n == <span class="hljs-number">0</span>;
    }
};
</div></code></pre>
<h3 id="263-%E4%B8%91%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/ugly-number/description/?envType=study-plan-v2&amp;envId=primers-list">263. 丑数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>丑数 就是只包含质因数 2、3 和 5 的 正 整数。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>我的思路是循环判断，但无法处理多个相同质因数。</li>
<li>位运算优化/数学法：
<ol>
<li>如果 <code>n &lt;= 0</code>，返回 <code>false</code>。</li>
<li>依次去掉 <code>n</code> 中的因子 <code>3</code>，直到 <code>n</code> 不是 <code>3</code> 的倍数。</li>
<li>同理去掉 <code>n</code> 中的因子 <code>5</code>。</li>
<li>最后只剩下因子 <code>2</code>，即判断 <code>n</code> 是否为 <code>2</code> 的某次幂。</li>
</ol>
</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">while</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
            n /= <span class="hljs-number">3</span>;
        }
        <span class="hljs-keyword">while</span> (n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
            n /= <span class="hljs-number">5</span>;
        }

        <span class="hljs-keyword">while</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) n/=<span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//或者这三行直接写成return (n &amp; (n - 1)) == 0;</span>
    }
};
</div></code></pre>
<h3 id="867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/transpose-matrix/?envType=study-plan-v2&amp;envId=primers-list">867. 转置矩阵</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。
矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>太生疏了，错误好多；</li>
<li>二元数组计算行和列 <code>m = matrix.size()</code>, <code>n = matrix[0].size()</code>。</li>
<li>赋值 <code>ans[j][i] = matrix[i][j]</code>。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">transpose</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{
        <span class="hljs-keyword">int</span> m = matrix.size();         <span class="hljs-comment">// 行</span>
        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].size();      <span class="hljs-comment">// 列</span>

        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m))</span></span>; <span class="hljs-comment">// n x m</span>

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){
                ans[j][i] = matrix[i][j];
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1422-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-score-after-splitting-a-string/?envType=study-plan-v2&amp;envId=primers-list">1422. 分割字符串的最大得分</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。</p>
<p>「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>暴力法 O(n^2)。</li>
<li>前缀和 O(n)。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> n = s.size();
        
        <span class="hljs-comment">// 方法1：前缀和数组（清晰易懂）</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prefixZero</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 前缀0的个数</span>
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prefixOne</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;   <span class="hljs-comment">// 前缀1的个数</span>
        
        <span class="hljs-comment">// 构建前缀和数组</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'0'</span>) {
                    prefixZero[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
                    prefixOne[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                } <span class="hljs-keyword">else</span> {
                    prefixZero[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                    prefixOne[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
                }
            } <span class="hljs-keyword">else</span> {
                prefixZero[i] = prefixZero[i<span class="hljs-number">-1</span>] + (s[i] == <span class="hljs-string">'0'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
                prefixOne[i] = prefixOne[i<span class="hljs-number">-1</span>] + (s[i] == <span class="hljs-string">'1'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
            }
        }
        
        <span class="hljs-keyword">int</span> totalOnes = prefixOne[n<span class="hljs-number">-1</span>];
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-comment">// 左子串0的个数：prefixZero[i]</span>
            <span class="hljs-comment">// 右子串1的个数：totalOnes - prefixOne[i]</span>
            <span class="hljs-keyword">int</span> score = prefixZero[i] + (totalOnes - prefixOne[i]);
            ans = max(ans, score);
        }
        
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="2586-%E7%BB%9F%E8%AE%A1%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/description/?envType=study-plan-v2&amp;envId=primers-list">2586. 统计范围内的元音字符串数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个下标从 0 开始的字符串数组 words 和两个整数 left、right。</p>
<p>如果一个字符串以元音字母开头且以元音字母结尾（元音为 'a', 'e', 'i', 'o', 'u'），则称其为元音字符串。</p>
<p>返回在闭区间 [left, right] 内，words[i] 为元音字符串的数量。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>计数器，判断函数。</li>
<li>灵神优雅版：利用 string 的 <code>find</code> 方法。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vowelStrings</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> vowel = <span class="hljs-string">"aeiou"</span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++) {
            <span class="hljs-built_in">string</span>&amp; s = words[i];
            ans += vowel.find(s[<span class="hljs-number">0</span>]) != <span class="hljs-built_in">string</span>::npos &amp;&amp;
                   vowel.find(s.back()) != <span class="hljs-built_in">string</span>::npos;
                   <span class="hljs-comment">//充分利用string的迭代器</span>
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/?envType=study-plan-v2&amp;envId=primers-list">852. 山脉数组的峰顶索引</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>符合下列属性的数组 arr 称为 山脉数组 ：</p>
<ul>
<li>arr.length &gt;= 3</li>
<li>存在 i（0 &lt; i &lt; arr.length - 1）使得：
<ul>
<li>arr[0] &lt; arr[1] &lt; ... &lt; arr[i-1] &lt; arr[i]</li>
<li>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</li>
</ul>
</li>
</ul>
<p>给你一个整数数组 arr，它保证是一个山脉，请你找出并返回顶部所在的山峰元素 <code>arr[i]</code> 的下标 <code>i</code>。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>二分查找。</li>
<li><code>mid = l + (r - l) / 2</code> 防止溢出。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = arr.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt; r) {
            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (arr[mid] &lt; arr[mid + <span class="hljs-number">1</span>]) {  <span class="hljs-comment">// 上升阶段</span>
                l = mid + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {                        <span class="hljs-comment">// 下降阶段</span>
                r = mid;
            }
        }
        <span class="hljs-keyword">return</span> l; <span class="hljs-comment">// 或 r，二者相等</span>
    }
};
</div></code></pre>
<h2 id="%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">不定长滑动窗口</h2>
<h3 id="3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-badge-type%22warning%22-text%22%E6%9C%AA%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串</a> <Badge type="warning" text="未解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>需要熟练运用map，重复想到set或map，连续子串想到窗口</li>
<li>要注意这些：
<ul>
<li>一是连续性，abca，滑动到第二个a，删除最左边的就行</li>
<li>二是注意这个while可以让指针连续移动，直到重复字符那里</li>
<li>三是复杂度O（n），虽然嵌套了 while，但每个字符最多被 left 和 right 各访问一次</li>
</ul>
</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> n = s.length(), ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; cnt; <span class="hljs-comment">// 维护从下标 left 到下标 right 的字符</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++) {
            <span class="hljs-keyword">char</span> c = s[right];
            cnt[c]++;
            <span class="hljs-keyword">while</span> (cnt[c] &gt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// 窗口内有重复字母</span>
            <span class="hljs-comment">//注意，这里不是用count，直接用value就行了</span>
                cnt[s[left]]--; <span class="hljs-comment">// 移除窗口左端点字母</span>
                left++; <span class="hljs-comment">// 缩小窗口</span>
            }
            ans = max(ans, right - left + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新窗口长度最大值</span>
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1493-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">1493. 删掉一个元素以后全为1的最长子数组</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个二进制数组 nums ，你需要从中删掉一个元素。
请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。
如果不存在这样的子数组，请返回 0 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<p>最长的子数组 - 不定长滑动窗口
用样例模拟了一下，发现： 删掉一个元素 - map中的 0 键对应的值 只能为1</p>
<p>那么问题转化为： 只含一个0的最长滑动窗口长度减去1，，，做的时候发现答案也可以是value（1）</p>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-comment">//不定长滑动窗口，问题可以转化为，只含1个0的最长滑动窗口的值减去1</span>
        <span class="hljs-comment">//int，int型的map，</span>
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, ans  = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){
            mp[nums[i]]++;

            <span class="hljs-keyword">while</span>(mp[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>){
                mp[nums[l]]--;
                l++;
            }
            
            ans = max(ans,mp[<span class="hljs-number">1</span>]);
        }
        <span class="hljs-keyword">return</span> mp[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? ans - <span class="hljs-number">1</span> : ans;

    }
};
</div></code></pre>
<h3 id="3411-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E9%99%A4%E6%95%B0%E7%9B%AE-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/minimum-removals-to-balance-array/description/">3411. 使数组平衡的最少移除数目</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个整数数组 nums 和一个整数 k。
如果一个数组的 最大 元素的值 至多 是其 最小 元素的 k 倍，则该数组被称为是 平衡 的。
你可以从 nums 中移除 任意 数量的元素，但不能使其变为 空 数组。</p>
<p>返回为了使剩余数组平衡，需要移除的元素的 最小 数量。</p>
<p>注意：大小为 1 的数组被认为是平衡的，因为其最大值和最小值相等，且条件总是成立。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<p>子数组，这个窗口是不断减小的可以先排序吧，排序之后，样例通过
好吧，错误，没有考虑到可以移除最小值
好吧，解答错误，其实也可以移除左边再右边，那么思路应该是
逆向思路，排好序，求符合条件的最长子数组，一旦不符合条件，左指针右移动，更新答案，
返回长度减去最长的子数组长度</p>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minRemoval</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//子数组，这个窗口是不断减小的可以先排序吧，排序之后，样例通过</span>
        <span class="hljs-comment">//好吧，错误，没有考虑到可以移除最小值</span>
        <span class="hljs-comment">//好吧，解答错误，其实也可以移除左边再右边，那么思路应该是</span>
        <span class="hljs-comment">//逆向思路，排好序，求符合条件的最长子数组，一旦不符合条件，左指针右移动，更新答案，</span>
        <span class="hljs-comment">//返回长度减去最长的子数组长度</span>
        sort(nums.begin(),nums.end());
        <span class="hljs-keyword">int</span> n = nums.size(),l = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">while</span>(nums[i] &gt; nums[l]*(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)k){
                l++;
            }
            res = max(res,i - l + <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> n - res;
    }
};
</div></code></pre>
<h3 id="1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89-badge-type%22warning%22-text%22%E6%9C%AA%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/description/">1208. 尽可能使字符串相等</a> <Badge type="warning" text="未解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给两个长度相同的字符串，s 和 t。</p>
<p>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>
<p>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>
<p>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。</p>
<p>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<p>...</p>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 代码</span>
</div></code></pre>
<h3 id="904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/fruit-into-baskets/description/">904. 水果成篮</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<p>两个篮子，试试用map的size函数吧，
进入map，当size&gt;=3 左边删，左边出
ans = max....
不定长</p>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; fruits)</span> </span>{
        <span class="hljs-comment">//两个篮子，试试用map的size函数吧，</span>
        <span class="hljs-comment">//进入map，当size&gt;=3 左边删，左边出</span>
        <span class="hljs-comment">//ans = max....</span>
        <span class="hljs-comment">//不定长</span>
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fruits.size(); i++){
            mp[fruits[i]]++;
            <span class="hljs-keyword">while</span>(mp.size() &gt; <span class="hljs-number">2</span>){
                mp[fruits[l]]--;
                <span class="hljs-keyword">if</span>(mp[fruits[l]] == <span class="hljs-number">0</span>) mp.erase(fruits[l]);
                l++;
            }
            ans = max(ans, i - l + <span class="hljs-number">1</span>);

        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h2 id="%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">定长滑动窗口</h2>
<h3 id="1456-%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">1456. 定长子串中元音的最大数目</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你字符串 s 和整数 k 。</p>
<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的元音字母为（a, e, i, o, u）。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>右侧进入，更新答案，左侧离开,</li>
<li>初始化右侧 开始循环</li>
<li>右侧指针可以从0开始判断元音</li>
<li>左侧根据长度来的 i - k + 1,注意小于0 的情况；</li>
<li>更新答案</li>
<li>删左侧</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxVowels</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//思路：右侧进入，更新答案，左侧离开,</span>
        <span class="hljs-comment">//初始化右侧 开始循环</span>
        <span class="hljs-comment">//右侧指针可以从0开始判断元音</span>
        <span class="hljs-comment">//左侧根据长度来的 i - k + 1,注意小于0 的情况；</span>
        <span class="hljs-comment">//更新答案</span>
        <span class="hljs-comment">//删左侧</span>
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, v = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++){
            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">'a'</span> || s[i] == <span class="hljs-string">'e'</span> || s[i] == <span class="hljs-string">'i'</span> || s[i] == <span class="hljs-string">'o'</span> || s[i] == <span class="hljs-string">'u'</span>) v++;

            <span class="hljs-keyword">int</span> left = i - k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

            ans = max(ans,v);

            <span class="hljs-keyword">if</span> (s[left] == <span class="hljs-string">'a'</span> || s[left] == <span class="hljs-string">'e'</span> || s[left] == <span class="hljs-string">'i'</span> || s[left] == <span class="hljs-string">'o'</span> || s[left] == <span class="hljs-string">'u'</span>) v--;

        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-i-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-average-subarray-i/description/">643. 子数组最大平均数 I</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。</p>
<p>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>通过循环遍历，循环i作为右侧点r，l ，不满足就继续+，满足就取最大，最后减掉左边;可以先求出和再平均；</li>
<li>当nums里面的数据为负，取max得到0;</li>
<li>写完代码一定要在脑海里模拟</li>
<li>根据gpt的建议，作如下修改，使得不需要定义极小值</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMaxAverage</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//思路：通过循环遍历，循环i作为右侧点r，l ，不满足就继续+，满足就取最大，最后减掉左边;可以先求出和再平均；</span>
        <span class="hljs-keyword">double</span> tmp = <span class="hljs-number">0</span>, ans = <span class="hljs-number">-10000000</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){
            tmp += nums[i];
            <span class="hljs-comment">//tmp /= (double)k;</span>
            <span class="hljs-keyword">int</span> l = i - k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            ans = max(ans,tmp);
            tmp -= nums[l];
        }
        <span class="hljs-keyword">return</span> ans / k;
    }
};
</div></code></pre>
<p><strong>优化写法</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">double</span> tmp = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) tmp += nums[i];
<span class="hljs-comment">//初始化tmp和ans</span>
<span class="hljs-keyword">double</span> ans = tmp / k;
</div></code></pre>
<p><strong>常量记忆</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-comment">//求最大</span>
<span class="hljs-keyword">int</span>:        INT_MIN（或<span class="hljs-number">-2e9</span>）
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>:  LLONG_MIN（或<span class="hljs-number">-1e18</span>）
<span class="hljs-keyword">double</span>:     <span class="hljs-number">-1e18</span>（或 -inf）
<span class="hljs-comment">//求最小</span>
<span class="hljs-keyword">int</span>:        INT_MAX
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>:  LLONG_MAX
<span class="hljs-keyword">double</span>:     <span class="hljs-number">1e18</span>（或 +inf）
</div></code></pre>
<p>对于inf，在leetcode无法添加库，所以用<code>double ans = -std::numeric_limits&lt;double&gt;::infinity();</code></p>
<h3 id="2090-%E5%8D%8A%E5%BE%84%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/k-radius-subarray-averages/">2090. 半径为 k 的子数组平均值</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。</p>
<p>半径为 k 的子数组平均值 是指：中心点是数组 nums 中某个下标 i 的子数组，并具有中心点 左边 k 个元素和 右边 k 个元素。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>vector初始化为-1技巧</li>
<li>看懂报错: <code>runtime error: signed integer overflow</code> -&gt; 数据范围 <code>2e10</code> 超过 <code>int</code> 上限 <code>2e9</code>。</li>
<li>窗口大小（window_size）: <code>window_size = 2 * k + 1</code></li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 略 (原文档未提供完整代码，建议补充)</span>
</div></code></pre>
<h3 id="2841-%E5%87%A0%E4%B9%8E%E5%94%AF%E4%B8%80%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/">2841. 几乎唯一子数组最大和</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定整数数组 <code>nums</code> 及正整数 <code>m</code>、<code>k</code>（<code>1 &lt;= m &lt;= k &lt;= nums.length</code>），求长度为 <code>k</code> 且至少含 <code>m</code> 个不同元素的子数组的最大和，无此类子数组则返回 <code>0</code>。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>此题涉及到哈希表！</li>
<li>不知道怎么判断子数组至少有m个互不相同的元素，查了一下用unordered_map，这个是互异，无序的</li>
<li>窗口先写好，然后判断的时候，用 <code>.size()</code></li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//不知道怎么判断子数组至少有m个互不相同的元素，查了一下用unordered_map，这个是互异，无序的</span>
        <span class="hljs-comment">//窗口先写好，然后判断的时候，用。size（）</span>
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里改成long long</span>
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; cnt;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){
            tmp += nums[i];
            cnt[nums[i]]++;

            <span class="hljs-keyword">int</span> l = i - k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(cnt.size() &gt;= m) ans = max(ans,tmp);

            tmp -= nums[l];
            cnt[nums[l]]--;
            <span class="hljs-keyword">if</span>(cnt[nums[l]]==<span class="hljs-number">0</span>) cnt.erase(nums[l]); <span class="hljs-comment">// 修正：删掉键</span>

        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="2461-%E9%95%BF%E5%BA%A6%E4%B8%BA-k-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/">2461. 长度为 K 子数组中的最大和</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个整数数组 nums 和一个整数 k 。请你找出 nums 中满足下述条件的一个子数组：</p>
<ul>
<li>长度为 k</li>
<li>所有元素各不相同</li>
</ul>
<p>返回满足题意子数组的最大元素和。如果不存在这样的子数组，返回 0 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>一是<code>unordered_map.count(val)</code>辨析</li>
<li><code>.size()</code> can count the number of elements because of the <code>uniqueness of map</code></li>
<li>注意数据类型，滑动窗口，进i，更新答案，出l，注意边界</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">maximumSubarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//思路：注意数据类型，滑动窗口，进i，更新答案，出l，注意边界</span>
        <span class="hljs-comment">//子数组中的所有元素 各不相同 。还是不熟悉map，搞一个无序map，利用互异性(元素各不相同），size函数，count函数erase函数</span>
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>,  tmp = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){
            tmp += nums[i];
            cnt[nums[i]]++;
            <span class="hljs-keyword">int</span> l = i - k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(cnt.size() == k)
                ans = max(ans,tmp); <span class="hljs-comment">//ans &gt; tmp ? ans : tmp;</span>
            tmp -= nums[l];
            cnt[nums[l]]--;
            <span class="hljs-keyword">if</span>(cnt[nums[l]] == <span class="hljs-number">0</span>)
                cnt.erase(nums[l]);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="1423-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/">1423. 可获得的最大点数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。
每次行动，你可以从行的开头或者末尾拿走一张卡牌，最终你必须正好拿走 k 张卡牌。
你的点数就是你拿到手中的所有卡牌的点数之和。
给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>可以从左开始拿，从右边开始拿，拿到定长为k的数目的卡片，返回卡片点数可能的最大之和；痛点在于左右两边</li>
<li>C++17引入的 <code>reduce</code>函数 快速计算窗口和</li>
<li>最多，想到对立面最少，转化为定长滑动窗口</li>
<li>需要意识到，左右两边都可以随机拿一张，可以想到所有的可能有哪些
<ul>
<li>左边0个 右边k个</li>
<li>左边1个 右边k-1个</li>
</ul>
</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<p><strong>反面计算</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-comment">//两边最大，中间最小，从0滑到n - k，最后答案要用总和减一下，另外考虑特殊情况</span>
        <span class="hljs-comment">//当全部都是一样的元素的时候，同上</span>
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1e9</span>, tmp = <span class="hljs-number">0</span>, j = cardPoints.size() - k;
        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> reduce(cardPoints.begin(),cardPoints.end());
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cardPoints.size();i++){
            tmp += cardPoints[i];

            <span class="hljs-keyword">int</span> l = i - j + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(l &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            ans = min(ans,tmp);

            tmp -= cardPoints[l];

        }
        <span class="hljs-keyword">return</span> reduce(cardPoints.begin(),cardPoints.end()) - ans;
    }
};
</div></code></pre>
<p><strong>正面计算</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cardPoints, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">int</span> s = reduce(cardPoints.begin(), cardPoints.begin() + k);
        <span class="hljs-keyword">int</span> ans = s;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) {
            s += cardPoints[cardPoints.size() - i] - cardPoints[k - i];
            ans = max(ans, s);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
</div></code></pre>
<h3 id="%E5%A3%AB%E5%85%B5%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98"><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1276">士兵队列问题</a></h3>
<ul>
<li>hint: 双队列模拟</li>
<li>get: while使用场景，深入理解dequeue</li>
<li>约瑟夫变式问题</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Queue&lt;<span class="hljs-keyword">int</span>&gt; q1,q2;
	<span class="hljs-keyword">int</span> t;
	<span class="hljs-built_in">cin</span> &gt;&gt; t;
	<span class="hljs-keyword">while</span>(t--){
		<span class="hljs-keyword">int</span> n;
		<span class="hljs-built_in">cin</span> &gt;&gt; n;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) q1.enqueue(i);
		<span class="hljs-keyword">while</span>(q1.getSize() &gt; <span class="hljs-number">3</span>){
			<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
			<span class="hljs-comment">//筛选报1的到2队</span>
			<span class="hljs-keyword">while</span>(q1.getSize()){ <span class="hljs-comment">//最终会排空，之前还一直理解不了，还以为执行完会有元素</span>
				<span class="hljs-keyword">int</span> v = q1.dequeue();
				++cnt;
				<span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) q2.enqueue(v);
			}
			<span class="hljs-comment">//考虑q2特殊情况</span>
			<span class="hljs-keyword">if</span>(q2.getSize() &lt;= <span class="hljs-number">3</span>) {
				<span class="hljs-keyword">while</span>(q2.getSize()) q1.enqueue(q2.dequeue());
				<span class="hljs-keyword">break</span>;
			}
			
			cnt = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">while</span>(q2.getSize()){
				<span class="hljs-keyword">int</span> v = q2.dequeue();
				++cnt;
				<span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>||cnt % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) q1.enqueue(v);
			}
		}
		<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span>(q1.getSize()){
			<span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">' '</span>;
			<span class="hljs-built_in">cout</span> &lt;&lt; q1.dequeue() ;
			flag++;
		}	
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
	}
	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="%E5%9B%A2%E9%98%9F%E9%98%9F%E5%88%97"><a href="https://acm.hdu.edu.cn/showproblem.php?pid=1387">团队队列</a></h3>
<ul>
<li>hint:</li>
<li>get: <code>memset(x,val,sizeof(x))</code>,辨析<code>Queue&lt;int&gt; q[1001]</code>,哈希表？</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// team[x] 存储成员 x 的 teamId，范围按题意预留（这里示例为 1e6）</span>
<span class="hljs-keyword">int</span> team[<span class="hljs-number">1000000</span>];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">int</span> t;                 
	<span class="hljs-keyword">int</span> cases = <span class="hljs-number">0</span>;         
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; t &amp;&amp; t){  <span class="hljs-comment">// 多个测试用例，读到 0 结束</span>
		cases++;
		<span class="hljs-built_in">memset</span>(team, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(team));

		<span class="hljs-comment">// 读入每个团队的成员，建立 id -&gt; teamId 的映射</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= t; i++){
			<span class="hljs-keyword">int</span> n;          
			<span class="hljs-built_in">cin</span> &gt;&gt; n;
			<span class="hljs-keyword">while</span>(n--){
				<span class="hljs-keyword">int</span> x;      
				<span class="hljs-built_in">cin</span> &gt;&gt; x;
				team[x] = i; <span class="hljs-comment">// 记录 x 属于第 i 个团队</span>
			}
		}

		Queue&lt;<span class="hljs-keyword">int</span>&gt; q[<span class="hljs-number">1001</span>]; <span class="hljs-comment">//注意，这个可不是tmd（），这是1001个队列，而不是一个队列；就这个问题半天理解不了；</span>
		<span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;   <span class="hljs-comment">// s 为队头团队索引，e 为队尾后一位（半开区间）</span>
		<span class="hljs-built_in">string</span> str;
		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Scenario #"</span> &lt;&lt; cases &lt;&lt; <span class="hljs-built_in">endl</span>;

		<span class="hljs-comment">// 处理操作，直到遇到 STOP</span>
		<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; str){
			<span class="hljs-keyword">if</span>(str == <span class="hljs-string">"STOP"</span>) <span class="hljs-keyword">break</span>;

			<span class="hljs-keyword">if</span>(str == <span class="hljs-string">"ENQUEUE"</span>){
				<span class="hljs-keyword">int</span> x, i; <span class="hljs-comment">// 这个i挺巧妙哈</span>
				<span class="hljs-built_in">cin</span> &gt;&gt; x; <span class="hljs-comment">// 待入队的成员 id</span>

				<span class="hljs-comment">// 在线性扫描当前存在的团队区间，寻找 x 所属团队是否已在队列中</span>
				<span class="hljs-keyword">for</span>(i = s; i &lt; e; i++){
					<span class="hljs-comment">// 用该团队队列的队首元素判断该 q[i] 属于哪个 teamId</span>
					<span class="hljs-keyword">if</span>(team[q[i].getFront()] == team[x]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到所属团队，这个i记上了</span>
				}

				<span class="hljs-comment">// 将 x 压入找到的团队队列；如果没找到（i==e），则相当于新团队入队</span>
				q[i].enqueue(x);
				<span class="hljs-keyword">if</span>(i == e) e++; <span class="hljs-comment">// 新团队出现，扩展总队列的尾部</span>
			}
			<span class="hljs-keyword">else</span>{ <span class="hljs-comment">// DEQUEUE</span>
				<span class="hljs-comment">// 弹出当前队头团队的队首成员</span>
				<span class="hljs-keyword">int</span> val = q[s].dequeue();
				<span class="hljs-comment">// 若该团队已空，则整个团队出队</span>
				<span class="hljs-keyword">if</span>(q[s].getSize() == <span class="hljs-number">0</span>) s++;
				<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-built_in">endl</span>;
			}
		}

		<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 每个场景后输出空行</span>
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre><code class="language-mermaid"><div class="mermaid">flowchart TD
    A[开始: 读入 t]
    A --> B{t 是否为 0?}
    B -- 是 --> Z[结束]
    B -- 否 --> C[构建 team 映射]
    C --> D[初始化 s 为 0，e 为 0]
    D --> E{读取一条操作}
    E -- STOP --> X[打印空行并进入下一个场景]
    E -- ENQUEUE --> F[在现有团队区间查找所属团队]
    F -- 找到 --> G[将 x 追加到该团队队尾]
    F -- 未找到 --> H[创建新团队并入队]
    G --> E
    H --> E
    E -- DEQUEUE --> I[从队头团队弹出队首成员]
    I --> J{该团队是否为空?}
    J -- 是 --> K[移除该团队]
    J -- 否 --> L[保留该团队]
    K --> M[输出 val]
    L --> M[输出 val]
    M --> E
    X --> A
</div></code></pre>
<h3 id="ping"><a href="https://leetcode.cn/problems/number-of-recent-calls/">ping</a></h3>
<ul>
<li>hint: 照着样例来就行了</li>
<li>get:</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecentCounter</span> {</span>
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
<span class="hljs-keyword">public</span>:
    RecentCounter() {
        
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>{
        q.push(t);
        <span class="hljs-keyword">while</span>(t - q.front() &gt; <span class="hljs-number">3000</span>){
            q.pop();
        }
        <span class="hljs-keyword">return</span> q.size();
    }
};
</div></code></pre>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%A8%A1%E7%89%88">顺序表模版</a></li>
<li><a href="#hdu-%E5%9F%BA%E7%A1%80%E9%A2%98">HDU 基础题</a></li>
<li><a href="#leetcode-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">Leetcode 数组操作</a></li>
</ul>
<h2 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%A8%A1%E7%89%88">顺序表模版</h2>
<h3 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0"><a href="Sqlisttmp.cpp">顺序表实现</a></h3>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li><code>elements</code> 的类型是 <code>eletype*</code>，它是“指针变量”，本身只存地址，不是数组。</li>
<li><code>new</code> 申请内存，<code>delete[]</code> 释放内存。</li>
<li>扩容机制：申请新内存 -&gt; 拷贝旧数据 -&gt; 释放旧内存 -&gt; 指向新内存。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">//增删改查</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eletype int </span>
<span class="hljs-comment">//便于修改：如果以后想把元素类型从 int 改为 double，只需要改一行</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sequentiallist</span>{</span>
    <span class="hljs-comment">/* =====================【要点1｜显眼说明】===================== 
       elements 的类型是 eletype*，它是“指针变量”，本身只存地址，不是数组。
       之所以能写 elements[i]，是因为第19行 new 之后，它会指向一段
       “连续的 eletype 元素内存”，下标运算只是“指针 + 偏移”的语法糖。
       区别提醒：
       - sizeof(elements) 得到的是指针大小（通常8字节），不是数组大小；
       - 指针可以被重新赋值（指向别处），数组名在作用域内不可被重新赋值。
       ========================================================= */</span>
    eletype *elements;

    <span class="hljs-keyword">int</span> size; 
    <span class="hljs-keyword">int</span> capacity; 
    <span class="hljs-comment">//size ≤ capacity，当size达到capacity时需要扩容</span>
};

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initializelist</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> capacity)</span></span>{
    <span class="hljs-built_in">list</span>-&gt;elements = <span class="hljs-keyword">new</span> eletype[capacity];
    <span class="hljs-comment">/* =====================【要点2｜显眼说明】===================== 
       在堆上申请了 “capacity 个 eletype 的连续内存”，并把“首地址”赋给 elements。
       注意：像 int 这类内置类型，new[] 默认不清零；若需清零可写 new eletype[capacity]();
       访问指针指向的结构体成员用 -&gt;；若 list 是对象本身（非指针）则用 .
       ========================================================= */</span>

    <span class="hljs-built_in">list</span>-&gt;size = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">list</span>-&gt;capacity = capacity;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroylist</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>)</span></span>{
    <span class="hljs-comment">// 【要点4】delete[] 释放的是 elements 当前指向的“数组内存”，不是指针变量本身</span>
    <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">list</span>-&gt;elements;
    <span class="hljs-built_in">list</span>-&gt;elements = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 置空，避免悬空指针被误用</span>
    <span class="hljs-built_in">list</span>-&gt;size = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">list</span>-&gt;capacity = <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;size;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;size == <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> index, eletype element)</span></span>{
    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;size) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"invalid index"</span>);
    <span class="hljs-comment">//throw 抛出异常，用throw更加优雅，健壮，安全。</span>

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;size == <span class="hljs-built_in">list</span>-&gt;capacity){
        <span class="hljs-keyword">int</span> newcapacity = <span class="hljs-built_in">list</span>-&gt;capacity * <span class="hljs-number">2</span>;
        <span class="hljs-comment">//如果当前容量不够，则扩容</span>
        
        <span class="hljs-comment">/* =====================【要点3｜显眼说明｜扩容三步】=====================
           1) 先申请“新数组内存”（一排新的连续柜子）
           2) 再把“旧数组里的数据”逐个搬过去（拷贝内容）
           3) 最后把 elements 这个“指针标签”改贴到新数组（改指向，不拷贝内容）
           解释：newelements 与 list-&gt;elements 都是 eletype*，类型相同，只是指向不同内存。
           - 下方 for 循环：拷贝的是“内容”
           - list-&gt;elements = newelements;：只是“改指向”，完全不搬内容
           （等价写法：可用 std::copy 或 std::memcpy 来替代手写 for）
           ================================================================ */</span>
        eletype *newelements = <span class="hljs-keyword">new</span> eletype[newcapacity]; <span class="hljs-comment">// 1) 申请新内存</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;size; i++)              <span class="hljs-comment">// 2) 拷贝旧内容到新内存</span>
            newelements[i] = <span class="hljs-built_in">list</span>-&gt;elements[i];
        <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">list</span>-&gt;elements;                          <span class="hljs-comment">// 释放旧内存（不是删指针变量）</span>
        <span class="hljs-built_in">list</span>-&gt;elements = newelements;                     <span class="hljs-comment">// 3) 改指向到新内存</span>
        <span class="hljs-built_in">list</span>-&gt;capacity = newcapacity;
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">list</span>-&gt;size; i &gt; index; i--)
        <span class="hljs-built_in">list</span>-&gt;elements[i] = <span class="hljs-built_in">list</span>-&gt;elements[i<span class="hljs-number">-1</span>];
    <span class="hljs-built_in">list</span>-&gt;elements[index] = element;
    <span class="hljs-built_in">list</span>-&gt;size++;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">list</span>-&gt;size) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"invalid index"</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index; i &lt; <span class="hljs-built_in">list</span>-&gt;size - <span class="hljs-number">1</span>; i++)
        <span class="hljs-built_in">list</span>-&gt;elements[i] = <span class="hljs-built_in">list</span>-&gt;elements[i+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">list</span>-&gt;size--;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findElement</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, eletype element)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;size; i++)
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;elements[i] == element) <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function">eletype <span class="hljs-title">getElement</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">list</span>-&gt;size) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"invalid index"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;elements[index];
}

<span class="hljs-function">eletype <span class="hljs-title">updateElement</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> index, eletype value)</span></span>{
    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">list</span>-&gt;size) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"invalid index"</span>);
    <span class="hljs-built_in">list</span>-&gt;elements[index] = value;
}
</div></code></pre>
<h2 id="hdu-%E5%9F%BA%E7%A1%80%E9%A2%98">HDU 基础题</h2>
<h3 id="hdu-2006-%E6%B1%82%E5%A5%87%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2006">HDU 2006. 求奇数的乘积</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你n个整数，求他们中所有奇数的乘积。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>顺序表实现，遍历判断 <code>x % 2 == 1</code>，累乘。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">//比较快的</span>
<span class="hljs-keyword">int</span> a[<span class="hljs-number">1000</span>];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n){

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">int</span> x;
            <span class="hljs-built_in">cin</span> &gt;&gt; x;
            a[i] = x;
        }
        <span class="hljs-keyword">int</span> pro = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">if</span>(a[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) pro *= a[i];
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; pro &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}
<span class="hljs-comment">//模版思维，比赛可以打印带进去，细节不易出错。</span>
</div></code></pre>
<h3 id="hdu-2008-%E6%95%B0%E5%80%BC%E7%BB%9F%E8%AE%A1"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2008">HDU 2008. 数值统计</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>统计给定的n个数中，负数、零和正数的个数。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>遍历统计，注意浮点数比较。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="hljs-number">0</span>){<span class="hljs-comment">//不能是0个数</span>
        Sequentiallist l;
        initializelist(&amp;l,n);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">double</span> x;
            <span class="hljs-built_in">cin</span> &gt;&gt; x;
            insert(&amp;l,i,x);
        }
        <span class="hljs-keyword">int</span> neg = <span class="hljs-number">0</span>, zero = <span class="hljs-number">0</span>, pos = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">if</span>(getElement(&amp;l,i) &lt; <span class="hljs-number">0</span>) neg++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getElement(&amp;l,i) == <span class="hljs-number">0</span>) zero++;
            <span class="hljs-keyword">else</span> pos++;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; neg &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; zero &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; pos &lt;&lt; <span class="hljs-built_in">endl</span>;
        destroylist(&amp;l);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="hdu-2014-%E9%9D%92%E5%B9%B4%E6%AD%8C%E6%89%8B%E5%A4%A7%E5%A5%96%E8%B5%9B%E8%AF%84%E5%A7%94%E4%BC%9A%E6%89%93%E5%88%86"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2014">HDU 2014. 青年歌手大奖赛_评委会打分</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>得分规则为去掉一个最高分和一个最低分，然后计算平均得分。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>遍历找 max 和 min，求和 <code>sum</code>，最后 <code>(sum - max - min) / (n - 2)</code>。</li>
<li><code>iomanip</code> 控制输出精度 <code>fixed &lt;&lt; setprecision(2)</code>。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="hljs-number">0</span>){<span class="hljs-comment">//不能是0个数</span>
        Sequentiallist l;
        initializelist(&amp;l,n);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">double</span> x;
            <span class="hljs-built_in">cin</span> &gt;&gt; x;
            insert(&amp;l,i,x);
        }
        <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>, max = <span class="hljs-number">-1e9</span>, min = <span class="hljs-number">1e9</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){
            <span class="hljs-keyword">double</span> a = getElement(&amp;l,i);
            sum += a;
            <span class="hljs-keyword">if</span>(a &gt; max) max = a;
            <span class="hljs-keyword">if</span>(a &lt; min) min = a;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="hljs-number">2</span>) &lt;&lt; (sum - max - min) / (n - <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
        destroylist(&amp;l);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="leetcode-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">Leetcode 数组操作</h2>
<h3 id="2859-%E8%AE%A1%E7%AE%97-k-%E7%BD%AE%E4%BD%8D%E4%B8%8B%E6%A0%87%E5%AF%B9%E5%BA%94%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/description/">2859. 计算 K 置位下标对应元素的和</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li><code>__builtin_popcount(index)</code> 计算二进制中 1 的个数。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumIndicesWithKSetBits</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
            <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; (<span class="hljs-keyword">int</span>)nums.size(); ++index) {
                <span class="hljs-keyword">if</span> (__builtin_popcount(index) == k) {
                    result += nums[index];
                }
            }
            <span class="hljs-keyword">return</span> result;
        }
};
</div></code></pre>
<h3 id="3158-%E6%B1%82%E5%87%BA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E6%95%B0%E5%AD%97%E7%9A%84-xor-%E5%80%BC-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/find-the-xor-of-numbers-which-appear-twice/description/">3158. 求出出现两次数字的 XOR 值</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。
请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>用位集 visited 记录“是否出现过”。第 i 位代表数值 i。</li>
<li>若 <code>(visited &amp; (1&lt;&lt;x))</code> 非 0，说明 x 之前已出现，现在是第二次 =&gt; <code>ans ^= x</code>。</li>
<li>否则首次出现 =&gt; <code>visited |= (1&lt;&lt;x)</code>。</li>
<li>注意 <code>1LL &lt;&lt; x</code> 防止溢出。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xorOperation</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
            <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> visited = <span class="hljs-number">0</span> ;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){
                <span class="hljs-keyword">if</span>(visited &amp; ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">1</span>&lt;&lt;nums[i])){
                    ans ^= nums[i];
                }
                <span class="hljs-keyword">else</span> visited |= ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">1</span>&lt;&lt;nums[i]);<span class="hljs-comment">// ｜ 有1则1</span>
            }
            <span class="hljs-keyword">return</span> ans;
        }
    }; 
</div></code></pre>
<h3 id="2341-%E6%95%B0%E7%BB%84%E8%83%BD%E5%BD%A2%E6%88%90%E5%A4%9A%E5%B0%91%E6%95%B0%E5%AF%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/description/">2341. 数组能形成多少数对</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>从 nums 选出 两个 相等的 整数，从 nums 中移除这两个整数，形成一个 数对。
返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>暴力法：双重循环查找匹配，用 bool 数组标记已使用的元素。</li>
<li>更好的方法：哈希表计数，<code>cnt / 2</code> 是对数，<code>cnt % 2</code> 是剩余。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">numberOfPairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
            <span class="hljs-keyword">bool</span> a[<span class="hljs-number">100</span>] = {<span class="hljs-number">0</span>};
            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.size(); i++){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i ;j++){
                    <span class="hljs-keyword">if</span>(a[j]) <span class="hljs-keyword">continue</span>;
                    <span class="hljs-keyword">if</span>(nums[i]==nums[j]){
                        a[j]= a[i] = <span class="hljs-number">1</span> ;
                        cnt++;
                        <span class="hljs-keyword">break</span>;
                    }
                }
                
            }

            <span class="hljs-keyword">return</span> {cnt,nums.size()<span class="hljs-number">-2</span>*cnt};
        }
};
</div></code></pre>
<h3 id="119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-ii-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/pascals-triangle-ii/description/">119. 杨辉三角 II</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>二维数组模拟：<code>y[i][j] = y[i-1][j-1] + y[i-1][j]</code>。</li>
<li>滚动数组优化（一维数组从后往前更新）。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getRow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowIndex)</span> </span>{
            <span class="hljs-keyword">int</span> y[<span class="hljs-number">34</span>][<span class="hljs-number">34</span>];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowIndex; i++){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i ; j++) {
                    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||j==i) y[i][j] = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span> y[i][j] = y[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+y[i<span class="hljs-number">-1</span>][j];
                }
            }
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowIndex; i++) ans.push_back(y[rowIndex][i]);
            <span class="hljs-keyword">return</span> ans;
        }
};
</div></code></pre>
<h3 id="lcp-01-%E7%8C%9C%E6%95%B0%E5%AD%97-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/guess-numbers/description/">LCP 01. 猜数字</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>小A 和 小B 在玩猜数字游戏。小B 每次从 1, 2, 3 中随机选择一个数字，小A 也从 1, 2, 3 中选择一个数字进行猜测。他们一共进行三次这个游戏。请返回 小A 猜对了几次？</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>遍历比较 <code>guess[i] == answer[i]</code>。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">game</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; guess, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; answer)</span> </span>{<span class="hljs-comment">//标记</span>
            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
                <span class="hljs-keyword">if</span>(guess[i] == answer[i]) cnt++;
            }
            <span class="hljs-keyword">return</span> cnt;
        }
};
</div></code></pre>
<h3 id="27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>双指针：左指针指向待处理位置，右指针指向待检查元素。</li>
<li>或者双向指针：左边找等于val的，右边找不等于val的，交换。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>{
            <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=nums.size()<span class="hljs-number">-1</span>;
            <span class="hljs-keyword">while</span>(l &lt;= r){
                <span class="hljs-keyword">if</span>(nums[l] == val){
                    <span class="hljs-keyword">int</span> tmp = nums[l];
                    nums[l] = nums[r];
                    nums[r] = tmp;
                    r--;
                }
                <span class="hljs-keyword">else</span> l++;
            }
            <span class="hljs-keyword">return</span> l;
        }
    };
</div></code></pre>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<ul>
<li><a href="#%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86">链表遍历</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4">链表删除</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5">链表插入</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3">链表的递归和迭代</a></li>
</ul>
<h2 id="%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86">链表遍历</h2>
<h3 id="hdu-2041-%E8%B6%85%E7%BA%A7%E6%A5%BC%E6%A2%AF"><a href="https://acm.hdu.edu.cn/submit.php?pid=2041">HDU 2041. 超级楼梯</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>走楼梯问题本质是斐波那契数列，每次可以走1步或2步，当前状态由前两个状态决定；</li>
<li>设f(M)为到达第M级的走法数，最后一步要么从M-1级走1步，要么从M-2级走2步，递推公式f(M)=f(M-1)+f(M-2)；</li>
<li>边界条件：f(1)=1, f(2)=1</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div>f(M) = f(M-1) + f(M-2)
</div></code></pre>
<h3 id="1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/description/">1290. 二进制链表转整数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>二进制转十进制需要从高位到低位累加，每遍历一个节点相当于左移一位再加当前位；</li>
<li>遍历链表，每次将累积结果乘2(左移)再加上当前节点值，模拟二进制转十进制的加权求和过程；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDecimalValue</span><span class="hljs-params">(ListNode* head)</span> </span>{
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(head) {
        sum = sum*<span class="hljs-number">2</span> + head-&gt;val;  <span class="hljs-comment">// 核心算法</span>
        head = head-&gt;next;
    }
    <span class="hljs-keyword">return</span> sum;
}
</div></code></pre>
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%98-0202-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/description/">面试题 02.02. 返回倒数第 k 个节点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>倒数第k个节点可以用快慢指针解决，让快指针先走k步形成窗口；</li>
<li>快指针先走k步，然后快慢指针同步移动，当快指针到达末尾时慢指针正好指向倒数第k个节点；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>{
    ListNode *fast = head, *slow = head;
    <span class="hljs-keyword">while</span>(k--) fast = fast-&gt;next;  <span class="hljs-comment">// 快指针先走k步</span>
    
    <span class="hljs-keyword">while</span>(fast) {  <span class="hljs-comment">// 同步移动直到末尾</span>
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }
    <span class="hljs-keyword">return</span> slow-&gt;val;
}
</div></code></pre>
<h3 id="876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>快慢指针经典应用，快指针速度是慢指针的2倍，当快指针到达末尾时慢指针正好在中点；</li>
<li>快指针每次走2步，慢指针每次走1步，利用速度差找到中间位置，需注意快指针的边界条件；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>{
    ListNode *fast = head, *slow = head;
    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next) {
        fast = fast-&gt;next-&gt;next;  <span class="hljs-comment">// 快指针每次走两步</span>
        slow = slow-&gt;next;        <span class="hljs-comment">// 慢指针每次走一步</span>
    }
    <span class="hljs-keyword">return</span> slow;
}
</div></code></pre>
<h2 id="%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4">链表删除</h2>
<h3 id="203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>删除操作需要前驱指针，头节点删除是特殊情况，哑节点可以统一处理；</li>
<li>创建哑节点指向原链表头，用前驱指针遍历，检查下一个节点是否需要删除，需要则跳过，否则移动前驱指针；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>{
        ListNode* newhead = <span class="hljs-keyword">new</span> ListNode();
        newhead-&gt;next = head;
        ListNode* pre = newhead;
        <span class="hljs-keyword">while</span>(pre-&gt;next){
            <span class="hljs-keyword">if</span>(pre-&gt;next-&gt;val==val){
                    pre-&gt;next = pre-&gt;next-&gt;next;
            }
            <span class="hljs-keyword">else</span>{
                pre = pre-&gt;next;
            }
        }
        <span class="hljs-keyword">return</span> newhead-&gt;next;
    }
};
</div></code></pre>
<h3 id="237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p>
<p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。</p>
<p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>只给出要删除的节点指针，无法获取前驱，需要巧妙地将下一个节点的值覆盖当前节点；</li>
<li>将下一个节点的值复制到当前节点，然后删除下一个节点，等效于删除当前节点；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>{
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    }
};
</div></code></pre>
<h3 id="83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/submissions/662037181/">83. 删除排序链表中的重复元素</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>一般对于删除的问题都要定义前驱。</li>
<li>首先一定是返回head，然后定义curr和前驱，然后开始遍历。</li>
<li>用while可以删除连续的,注意pre也不能为空。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-comment">//一般对于删除的问题都要定义前驱？？</span>
        <span class="hljs-comment">//首先一定是返回head，然后定义curr和前驱，然后开始遍历</span>
        ListNode* curr = head;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(curr){
            <span class="hljs-keyword">while</span>(pre&amp;&amp;pre-&gt;val == curr-&gt;val){ <span class="hljs-comment">//用while可以删除连续的,注意pre也不能为空</span>
                pre-&gt;next = curr-&gt;next;
                curr = pre-&gt;next;
                <span class="hljs-keyword">if</span>(!curr) <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-comment">//删完之后继续遍历</span>
            <span class="hljs-keyword">if</span>(!curr) <span class="hljs-keyword">break</span>;
            pre = curr;
            curr = curr-&gt;next;<span class="hljs-comment">//看到这个操作就要想到是否为空</span>
        }
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h3 id="19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>双指针。</li>
<li>先让 fast 移动 n 次。</li>
<li>然后 fast 和 slow 一起移动。</li>
<li>pre 记录 slow 的前驱，最后删除 slow。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>{
        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(n--){
            fast = fast-&gt;next;
        }
        <span class="hljs-keyword">while</span>(fast){
            fast = fast-&gt;next;
            pre = slow;
            slow = slow-&gt;next;
        }
        <span class="hljs-keyword">if</span>(!pre) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">//别忘了考虑删除掉第一个元素</span>
        pre-&gt;next = slow-&gt;next;
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h2 id="%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5">链表插入</h2>
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%98-0201-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>哈希表去重。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeDuplicateNodes</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-comment">//一定要注意这里！！</span>
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//没有的话会产生空指针访问错误</span>
        ListNode* tmp = head;
        ListNode* pre = head;
        ListNode* curr = head-&gt;next;
        <span class="hljs-keyword">bool</span> hash[<span class="hljs-number">20001</span>] = {<span class="hljs-number">0</span>};
        hash[head-&gt;val] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(curr){
            <span class="hljs-keyword">if</span>(!hash[curr-&gt;val]){
                hash[curr-&gt;val] = <span class="hljs-number">1</span>;
                tmp-&gt;next = curr;
                tmp = tmp-&gt;next;
            }
            pre = curr;
            curr = curr-&gt;next;
        }
        tmp-&gt;next = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h2 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3">链表的递归和迭代</h2>
<h3 id="lcr-123-%E5%9B%BE%E4%B9%A6%E6%95%B4%E7%90%86-i-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/submissions/662069306/">LCR 123. 图书整理 I</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>书店店员需要再整理一种新的书架模式，该书架模式的特点是可以将书籍存放在一根长条形的链上。
现在请你写一个程序，返回一个数组，数组的元素是书籍的编号，顺序是从书架尾部到书架头部。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>遍历入栈（或vector），然后反转。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reverseBookList</span><span class="hljs-params">(ListNode* head)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
    <span class="hljs-keyword">while</span>(head){
        ans.push_back(head-&gt;val);
        head = head-&gt;next;
    }
    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = ans.size()<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span>(l &lt; r){
        <span class="hljs-keyword">int</span> temp = ans[l];
        ans[l] = ans[r];
        ans[r] = temp;
        l++;
        r--;
    }
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="lcr-024-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/UHnkqh/">LCR 024. 反转链表</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>递归法。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;
        ListNode* newhead = reverseList(head-&gt;next);<span class="hljs-comment">//看成整体就行了</span>
        head-&gt;next-&gt;next = head;
        head-&gt;next = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> newhead;
    }
};
</div></code></pre>
<h3 id="2487-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/description/">2487. 从链表中移除节点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个链表的头节点 head 。</p>
<p>移除每个右侧有一个更大数值的节点。</p>
<p>返回修改后链表的头节点 head 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>递归法。</li>
<li>如果右边有比当前节点大的，返回右边的结果（当前节点被跳过）。</li>
<li>否则当前节点保留，接上右边的结果。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeNodes</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;
        head-&gt;next = removeNodes(head-&gt;next);
        <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;
        <span class="hljs-keyword">if</span>(head-&gt;val &lt; head-&gt;next-&gt;val) <span class="hljs-keyword">return</span> head-&gt;next;
        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<h3 id="2816-%E7%BF%BB%E5%80%8D%E4%BB%A5%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%AD%97-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/description/">2816. 翻倍以链表形式表示的数字</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个 非空 链表的头节点 head ，表示一个不含前导零的非负整数。</p>
<p>将链表 翻倍 后，返回头节点 head 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>递归，从后往前处理进位。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dodouble</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> *cap)</span></span>{
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>){
            *cap = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">int</span> val;
        dodouble(head-&gt;next, &amp;val);
        head-&gt;val = head-&gt;val*<span class="hljs-number">2</span> + val;
        *cap = head-&gt;val / <span class="hljs-number">10</span>;
        head-&gt;val %= <span class="hljs-number">10</span>;
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">doubleIt</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">int</span> val;
        dodouble(head,&amp;val);
        <span class="hljs-keyword">return</span> val==<span class="hljs-number">0</span> ? head : <span class="hljs-keyword">new</span> ListNode(val,head);
    }
};
</div></code></pre>
<h3 id="206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>迭代法。</li>
<li>定义 pre, curr, next。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        ListNode* curr = head;
        <span class="hljs-keyword">while</span>(curr){
            ListNode* next = curr-&gt;next;
            curr-&gt;next = pre;<span class="hljs-comment">//箭头方向</span>
<span class="hljs-comment">//下面两行先写出来：往后移动</span>
            pre = curr;
            curr = next;
        }
        <span class="hljs-keyword">return</span> pre;
    }
};
</div></code></pre>
<h2 id="%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3">递归详解</h2>
<h3 id="%E9%80%92%E5%BD%92%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">递归的核心概念</h3>
<p>递归就是<strong>函数调用自己</strong>，但每次调用时处理的是<strong>更小的问题</strong>，直到达到<strong>基础情况</strong>（递归终止条件）。</p>
<h3 id="%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E7%9A%84%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3">链表反转的递归过程详解</h3>
<p>以链表 <code>1→2→3→4→NULL</code> 为例：</p>
<h4 id="%E7%AC%AC1%E6%AD%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6">第1步：理解递归终止条件</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> head;
</div></code></pre>
<ul>
<li>当链表为空或只有一个节点时，不需要反转，直接返回</li>
</ul>
<h4 id="%E7%AC%AC2%E6%AD%A5%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">第2步：递归调用过程</h4>
<pre class="hljs"><code><div>原始链表: 1→2→3→4→NULL

调用栈（从上到下）:
┌─────────────────────────────────┐
│ reverseList(1)                  │ ← 最外层调用
│ 调用 reverseList(2)             │
├─────────────────────────────────┤
│ reverseList(2)                  │
│ 调用 reverseList(3)             │
├─────────────────────────────────┤
│ reverseList(3)                  │
│ 调用 reverseList(4)             │
├─────────────────────────────────┤
│ reverseList(4)                  │ ← 基础情况，直接返回4
└─────────────────────────────────┘
</div></code></pre>
<h4 id="%E7%AC%AC3%E6%AD%A5%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B">第3步：递归返回过程</h4>
<p><strong>第1次调用：<code>reverseList(1)</code></strong></p>
<ul>
<li><code>head = 1</code>, <code>head-&gt;next = 2</code></li>
<li>不满足终止条件，继续递归</li>
<li>调用 <code>reverseList(2)</code> 并等待结果</li>
</ul>
<p><strong>第2次调用：<code>reverseList(2)</code></strong></p>
<ul>
<li><code>head = 2</code>, <code>head-&gt;next = 3</code></li>
<li>不满足终止条件，继续递归</li>
<li>调用 <code>reverseList(3)</code> 并等待结果</li>
</ul>
<p><strong>第3次调用：<code>reverseList(3)</code></strong></p>
<ul>
<li><code>head = 3</code>, <code>head-&gt;next = 4</code></li>
<li>不满足终止条件，继续递归</li>
<li>调用 <code>reverseList(4)</code> 并等待结果</li>
</ul>
<p><strong>第4次调用：<code>reverseList(4)</code></strong></p>
<ul>
<li><code>head = 4</code>, <code>head-&gt;next = NULL</code></li>
<li><strong>满足终止条件！</strong> 直接返回 <code>4</code></li>
</ul>
<h4 id="%E7%AC%AC4%E6%AD%A5%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9E%E5%92%8C%E5%8F%8D%E8%BD%AC%E6%93%8D%E4%BD%9C">第4步：递归返回和反转操作</h4>
<p>现在开始<strong>从内向外</strong>返回并执行反转：</p>
<p><strong>从 <code>reverseList(4)</code> 返回：</strong></p>
<ul>
<li>返回 <code>4</code>（单个节点，无需反转）</li>
</ul>
<p><strong>回到 <code>reverseList(3)</code>：</strong></p>
<pre class="hljs"><code><div>ListNode* newhead = reverseList(head-&gt;next); <span class="hljs-comment">// newhead = 4</span>
head-&gt;next-&gt;next = head;  <span class="hljs-comment">// 4-&gt;next = 3，形成 4→3</span>
head-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// 3-&gt;next = NULL</span>
<span class="hljs-keyword">return</span> newhead;           <span class="hljs-comment">// 返回 4</span>
</div></code></pre>
<p>现在链表变成：<code>4→3→NULL</code></p>
<p><strong>回到 <code>reverseList(2)</code>：</strong></p>
<pre class="hljs"><code><div>ListNode* newhead = reverseList(head-&gt;next); <span class="hljs-comment">// newhead = 4</span>
head-&gt;next-&gt;next = head;  <span class="hljs-comment">// 3-&gt;next = 2，形成 4→3→2</span>
head-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// 2-&gt;next = NULL</span>
<span class="hljs-keyword">return</span> newhead;           <span class="hljs-comment">// 返回 4</span>
</div></code></pre>
<p>现在链表变成：<code>4→3→2→NULL</code></p>
<p><strong>回到 <code>reverseList(1)</code>：</strong></p>
<pre class="hljs"><code><div>ListNode* newhead = reverseList(head-&gt;next); <span class="hljs-comment">// newhead = 4</span>
head-&gt;next-&gt;next = head;  <span class="hljs-comment">// 2-&gt;next = 1，形成 4→3→2→1</span>
head-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">// 1-&gt;next = NULL</span>
<span class="hljs-keyword">return</span> newhead;           <span class="hljs-comment">// 返回 4</span>
</div></code></pre>
<p>最终结果：<code>4→3→2→1→NULL</code></p>
<h1 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB">单向链表学习问题汇总</h1>
<h2 id="%E9%97%AE%E9%A2%981%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E6%9C%AC%E8%B4%A8">问题1：指针赋值的本质</h2>
<p><strong>问题描述</strong>：指针的 <code>=</code> 号是复制粘贴还是替换？</p>
<p><strong>答案</strong>：是<strong>复制粘贴</strong>，不是替换。</p>
<p><strong>详细解释</strong>：</p>
<ul>
<li><code>newNode-&gt;next = curr-&gt;next;</code> 是把 <code>curr-&gt;next</code> 存储的地址值复制给 <code>newNode-&gt;next</code></li>
<li>两个指针变量都存储相同的地址值，指向同一个对象</li>
<li>原指针 <code>curr-&gt;next</code> 的值没有改变，只是 <code>newNode-&gt;next</code> 的值改变了</li>
</ul>
<p><strong>出处</strong>：<code>源码.cpp</code> 第89行 <code>newNode-&gt;next = curr-&gt;next;</code></p>
<hr>
<h2 id="%E9%97%AE%E9%A2%982newnode-%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB%E7%9A%84%E5%8F%98%E5%8C%96">问题2：newNode 指针本身的变化</h2>
<p><strong>问题描述</strong>：newNode 这个指针也没变对吧？</p>
<p><strong>答案</strong>：是的，<strong><code>newNode</code> 指针本身没有变</strong>。</p>
<p><strong>详细解释</strong>：</p>
<ul>
<li><code>newNode</code> 始终指向同一个新创建的节点</li>
<li>我们只是修改了这个节点内部的 <code>next</code> 成员变量</li>
<li>指针变量存储的地址值保持不变</li>
</ul>
<p><strong>出处</strong>：<code>源码.cpp</code> 第89行 <code>newNode-&gt;next = curr-&gt;next;</code></p>
<hr>
<h2 id="%E9%97%AE%E9%A2%983%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81">问题3：链表插入操作的两行代码</h2>
<p><strong>问题描述</strong>：curr的next两个赋值不太好区分，上面那个是把i-1处结构体的next指针复制给了新节点的next指针，然后下面那一行是把指向新节点的指针又赋值给了谁？</p>
<p><strong>答案</strong>：</p>
<pre class="hljs"><code><div>newNode-&gt;next = curr-&gt;next;  <span class="hljs-comment">// 第89行</span>
curr-&gt;next = newNode;        <span class="hljs-comment">// 第91行</span>
</div></code></pre>
<p><strong>详细解释</strong>：</p>
<ul>
<li><strong>第89行</strong>：让新节点的 <code>next</code> 指针指向 <code>curr</code> 的下一个节点，建立新节点到后续节点的连接</li>
<li><strong>第91行</strong>：让 <code>curr</code> 的 <code>next</code> 指针指向新节点，建立前一个节点到新节点的连接</li>
<li><strong>顺序重要性</strong>：必须先执行第89行，再执行第91行，否则会丢失后面节点的连接</li>
</ul>
<p><strong>出处</strong>：<code>源码.cpp</code> 第89-91行</p>
<hr>
<h2 id="%E9%97%AE%E9%A2%984curr-%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E5%90%91">问题4：curr 指针的指向</h2>
<p><strong>问题描述</strong>：curr的指向不是很明白</p>
<p><strong>答案</strong>：<code>curr</code> 指向第i-1个节点（插入位置的前一个节点）</p>
<p><strong>详细解释</strong>：</p>
<ul>
<li>通过 <code>for (int j = 0; j &lt; i - 1; j++) curr = curr-&gt;next;</code> 来定位</li>
<li>在插入操作中，<code>curr</code> 始终指向要插入位置的前一个节点</li>
<li>这样设计是为了能够修改前一个节点的 <code>next</code> 指针，完成插入操作</li>
</ul>
<p><strong>出处</strong>：<code>源码.cpp</code> 第84-86行</p>
<hr>
<h2 id="%E9%97%AE%E9%A2%985%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3">问题5：链表插入的完整过程图解</h2>
<p><strong>插入前状态</strong>：</p>
<pre class="hljs"><code><div>head ──→ [10] ──→ [20] ──→ [30] ──→ [40] ──→ NULL
          ↑        ↑
        curr指向这里（第i-1个位置）
</div></code></pre>
<p><strong>执行第89行后</strong>：</p>
<pre class="hljs"><code><div>head ──→ [10] ──→ [20] ──→ [30] ──→ [40] ──→ NULL
          ↑        ↑        ↑
        curr      newNode指向30
</div></code></pre>
<p><strong>执行第91行后</strong>：</p>
<pre class="hljs"><code><div>head ──→ [10] ──→ [20] ──→ [25] ──→ [30] ──→ [40] ──→ NULL
          ↑        ↑        ↑
        curr      newNode
</div></code></pre>
<p><strong>出处</strong>：<code>源码.cpp</code> 第88-91行</p>
<hr>
<h2 id="%E6%80%BB%E7%BB%93">总结</h2>
<p>这些问题的核心在于理解：</p>
<ol>
<li>指针赋值是地址值的复制，不是替换</li>
<li>指针变量本身和它指向的对象是两个概念</li>
<li>链表插入需要保持链表的连续性，顺序很重要</li>
<li>通过图解可以更好地理解指针操作的过程</li>
</ol>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<ul>
<li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8">栈的应用</a></li>
<li><a href="#%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</a></li>
</ul>
<h2 id="%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</h2>
<h3 id="hdu-2051-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BD%AC2"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2051">HDU 2051. 进制转换-转2</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>输入一个十进制数N，将它转换成二进制数输出。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>十进制转二进制需要除2取余，余数序列需要逆序输出；</li>
<li>利用栈的特性，将余数依次入栈，然后出栈输出即可得到正确的二进制序列；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">int</span> n;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n){
    	Stack&lt;<span class="hljs-keyword">int</span>&gt; st;
		<span class="hljs-keyword">while</span>(n){
			st.push(n % <span class="hljs-number">2</span>);
			n /= <span class="hljs-number">2</span>;
		}
		<span class="hljs-keyword">while</span>(st.getSize()) <span class="hljs-built_in">cout</span> &lt;&lt; st.pop();
			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
		}
    	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
</div></code></pre>
<h3 id="hdu-2031-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BD%AC%E4%BB%BB%E6%84%8F"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2031">HDU 2031. 进制转换-转任意</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>输入一个十进制数N，将它转换成R进制数输出。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>任意进制转换需要处理负数标记和大于9的数字用字母表示；</li>
<li>先处理负数符号，然后按目标进制除法取余入栈，出栈时对大于等于10的数字转换为字母A-F；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">int</span> a,b;
	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b){
		Stack&lt;<span class="hljs-keyword">int</span>&gt; stk;
        <span class="hljs-comment">//考虑特殊情况</span>
		<span class="hljs-keyword">if</span>(a &lt; <span class="hljs-number">0</span>){      
			<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"-"</span>;
			a = - a;
		}
		<span class="hljs-keyword">while</span>(a){
			stk.push(a % b);
			a /= b;
		}
		<span class="hljs-keyword">while</span>(stk.getSize()){
			<span class="hljs-keyword">int</span> x = stk.pop();
			<span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">10</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, <span class="hljs-string">'A'</span> + x - <span class="hljs-number">10</span>);
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, x);
		}
		<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8">栈的应用</h2>
<h3 id="lcr-027-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/aMhZSa/">LCR 027. 回文链表</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个链表的头节点 head ，请判断其是否为回文链表。</p>
<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>回文需要正反两个方向比较，链表只能单向遍历，需要借助数据结构实现逆序；</li>
<li>第一次遍历将所有节点入栈，第二次遍历同时从头和栈顶(尾)开始比较值，不相等即非回文；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;ListNode*&gt; stk;
        ListNode* tmp = head;
        <span class="hljs-keyword">while</span>(tmp){
            stk.push(tmp);
            tmp = tmp-&gt;next;
        }
        <span class="hljs-keyword">while</span>(head){
            <span class="hljs-keyword">if</span>(head-&gt;val != stk.top()-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            stk.pop();
            head = head-&gt;next;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    }
};
</div></code></pre>
<h3 id="1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/">1614. 括号的最大嵌套深度</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>括号的嵌套深度等价于栈的最大深度，但不需要真正使用栈；</li>
<li>用计数器模拟栈深度，遇到左括号深度+1并更新最大值，遇到右括号深度-1；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>, top =<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++){
            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'('</span>){
                top++;
                tmp = max(tmp,top);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">')'</span>) top--;
        }
    <span class="hljs-keyword">return</span> tmp;
    }
};
</div></code></pre>
<h3 id="20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>括号匹配经典栈应用，左括号入栈，右括号匹配栈顶，需要处理空栈和不匹配情况；</li>
<li>遇到左括号直接入栈，遇到右括号检查栈是否为空和是否与栈顶匹配，最后检查栈是否为空；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isleft</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{
        <span class="hljs-keyword">return</span> c == <span class="hljs-string">'('</span> ||c == <span class="hljs-string">'['</span> || c==<span class="hljs-string">'{'</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ismatch</span><span class="hljs-params">(<span class="hljs-keyword">char</span> l, <span class="hljs-keyword">char</span> r)</span></span>{
        <span class="hljs-keyword">return</span> l == <span class="hljs-string">'('</span> &amp;&amp; r == <span class="hljs-string">')'</span> || l == <span class="hljs-string">'['</span> &amp;&amp; r ==<span class="hljs-string">']'</span> || l == <span class="hljs-string">'{'</span> &amp;&amp; r == <span class="hljs-string">'}'</span>;
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; stk;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++){
            <span class="hljs-keyword">if</span>(isleft(s[i])) stk.push(s[i]);
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">if</span>(stk.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span>(!ismatch(stk.top(),s[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                stk.pop();<span class="hljs-comment">//注意这行代码的位置和作用</span>
            }

        }
        <span class="hljs-keyword">return</span> stk.empty();<span class="hljs-comment">//这里</span>
    }
};
</div></code></pre>
<h2 id="%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</h2>
<h3 id="739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>寻找下一个更大元素的经典单调栈问题，栈中存储下标而非值；</li>
<li>维护单调递减栈存储下标，遇到更大温度时弹出栈中较小元素并计算距离，当前元素入栈；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.size(); i++) ans.push_back(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.size(); i++){
            <span class="hljs-keyword">while</span>(stk.size()&amp;&amp;temperatures[stk.back()] &lt; temperatures[i]){
                ans[stk.back()] = i - stk.back();
                stk.pop_back();
            }
            stk.push_back(i);
        }
        <span class="hljs-keyword">return</span> ans;
    }
};
<span class="hljs-comment">/*
考虑极端情况
1 2 3 4 5 6 
1 1 1 1 1 0

6 5 4 3 2 1
0 0 0 0 0 0 

在考虑普通情况
1 2 3 4 6 8 
*/</span>
</div></code></pre>
<h3 id="2487-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/description/">2487. 从链表中移除节点</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个链表的头节点 head 。</p>
<p>移除每个右侧有一个更大数值的节点。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>删除想到前驱，但是单调不增栈，需要头节点极大；遍历链表需要curr；</li>
<li>哑节点入栈（不是整个链表入了），比较，小于curr就弹出，节点整理好后处理指针；</li>
<li>单项链表也做过这道（递归）</li>
<li>既然可以用递归，那就一定可以用栈；深搜和栈联系起来广搜和队列联系起来；</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeNodes</span><span class="hljs-params">(ListNode* head)</span> </span>{
        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1000001</span>,head);
        ListNode* curr = head;
        <span class="hljs-built_in">vector</span>&lt;ListNode*&gt; stk;
        stk.push_back(dummy);
        <span class="hljs-keyword">while</span>(curr){
            <span class="hljs-keyword">while</span>(stk.back()-&gt;val &lt; curr-&gt;val) stk.pop_back();<span class="hljs-comment">//连续弹栈，把if改成while</span>
            stk.push_back(curr);
            curr = curr-&gt;next;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stk.size()<span class="hljs-number">-1</span>; i++) stk[i]-&gt;next = stk[i+<span class="hljs-number">1</span>];<span class="hljs-comment">//没有这个减一会报错；</span>
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }
};
</div></code></pre>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<ul>
<li><a href="#hdu-%E5%9F%BA%E7%A1%80%E9%A2%98">HDU 基础题</a></li>
<li><a href="#leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">Leetcode 字符串操作</a></li>
</ul>
<h2 id="hdu-%E5%9F%BA%E7%A1%80%E9%A2%98">HDU 基础题</h2>
<h3 id="hdu-2030-%E6%B1%89%E5%AD%97%E7%BB%9F%E8%AE%A1"><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2030">HDU 2030. 汉字统计</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>统计给定文本文件中汉字的个数。</p>
<ul>
<li>输入：输入文件首先包含一个整数n，表示测试实例的个数，然后是n段文本</li>
<li>输出：对于每一段文本，输出其中的汉字的个数，每个测试实例的输出占一行</li>
</ul>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>用char数组存储，注意忽略换行符，汉字机内码特征小于0，占两个字节，计数的时候，i++跳过一个字节。</li>
<li>汉字机内码：为了与ASCII码兼容（不冲突），规定组成汉字的两个字节的最高位都必须是1。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-built_in">cin</span>.ignore();<span class="hljs-comment">//&lt;iostream&gt;里</span>
<span class="hljs-comment">//or</span>
getchar();<span class="hljs-comment">//&lt;cstdio&gt;里</span>

<span class="hljs-comment">// gets编译错误</span>
<span class="hljs-keyword">char</span> s[<span class="hljs-number">500</span>];
gets(s);<span class="hljs-comment">//c11之后就被删了</span>
<span class="hljs-comment">// 改成c风格</span>
<span class="hljs-built_in">cin</span>.getline(s,<span class="hljs-number">500</span>);
<span class="hljs-comment">// 或者直接string库的</span>
getline(<span class="hljs-built_in">cin</span>,s);
</div></code></pre>
<h3 id="hdu-2026-%E9%A6%96%E5%AD%97%E6%AF%8D%E5%8F%98%E5%A4%A7%E5%86%99"><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2026">HDU 2026. 首字母变大写</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>输入一个英文句子，将每个单词的第一个字母改成大写字母。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>cin.getline输入，判断字母前面是空格，是就变大写，变大写-'a'+'A'；</li>
<li>检查 <code>'\0'</code>（空字符）而不是空格,空格是<code> </code>;</li>
<li>或者<code>s[i] = toupper(s[i])</code>,这个在<code>&lt;cctype&gt;</code></li>
</ul>
<h3 id="hdu-2025-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2025">HDU 2025. 查找最大元素</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>直接模拟不行么？</li>
</ul>
<h2 id="leetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">Leetcode 字符串操作</h2>
<h3 id="1812-%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2"><a href="https://leetcode.cn/problems/determine-color-of-a-chessboard-square/description/">1812. 判断国际象棋棋盘中一个格子的颜色</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个坐标 <code>coordinates</code>，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。如果所给格子的颜色是白色，返回 <code>true</code>；如果是黑色，返回 <code>false</code>。</p>
<ul>
<li><code>coordinates</code> 是长度为 2 的字符串，第一个字符是字母（'a'-'h'），第二个字符是数字（'1'-'8'）</li>
<li>下标之和为奇数 -&gt; 白色</li>
</ul>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>观察下标与白色格子的特征关系（下标之和为奇数），纵方向就是减去字符1，横坐标减去字符a；</li>
<li>运算符优先级，检查括号</li>
</ul>
<h3 id="lcr-122-%E8%B7%AF%E5%BE%84%E5%8A%A0%E5%AF%86"><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">LCR 122. 路径加密</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>假定一段路径记作字符串 <code>path</code>，其中以 &quot;.&quot; 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 &quot; &quot;，请返回加密后的字符串。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>跟算法书上的例题差不多，可以边输入边输出，如果不是字母就else；</li>
<li>单引号表示单个字符，双引号表示字符串</li>
</ul>
<h3 id="1876-%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%B8%89%E4%B8%94%E5%90%84%E5%AD%97%E7%AC%A6%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><a href="https://leetcode.cn/problems/substrings-of-size-three-with-distinct-characters/description/">1876. 长度为三且各字符不同的子字符串</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>如果一个字符串不含有任何重复字符，我们称这个字符串为<strong>好字符串</strong>。给你一个字符串 <code>s</code>，请你返回 <code>s</code> 中长度为 <strong>3</strong> 的<strong>好子字符串</strong>的数量。注意，如果相同的好子字符串出现多次，每一次都应该被记入答案之中。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>截取长度，判断是否有重复，计数器计数，注意边界。</li>
<li><code>s.size()-2</code> 当字符串小于3时，会变成一个很大的无符号数（因为 <code>size()</code>返回的是 <code>size_t</code>类型）。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size()<span class="hljs-number">-2</span>; i++) <span class="hljs-comment">// 错误写法，若size&lt;2会溢出</span>
</div></code></pre>
<h3 id="2011-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%80%BC-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/description/">2011. 执行操作后的变量值</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：</p>
<ul>
<li>++X 和 X++ 使变量 X 的值 加 1</li>
<li>--X 和 X-- 使变量 X 的值 减 1
最初，X 的值是 0</li>
</ul>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>直接模拟即可</li>
<li>两个不同操作得出一样的结果用<code>||</code>;</li>
</ul>
<h3 id="1108-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96"><a href="https://leetcode.cn/problems/defanging-an-ip-address/description/">1108. IP 地址无效化</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个有效的 IPv4 地址 <code>address</code>，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 <code>&quot;[.]&quot;</code> 代替了每个 <code>&quot;.&quot;</code>。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>不能直接替换，类型不匹配，<code>address[i]</code>是<code>char</code>类型，<code>'[.]'</code> 是字符串。</li>
<li>解决方案是<code>string</code>一个新串。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">defangIPaddr</span><span class="hljs-params">(<span class="hljs-built_in">string</span> address)</span> </span>{
    <span class="hljs-built_in">string</span> result;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : address) {
        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'.'</span>)result += <span class="hljs-string">"[.]"</span>;
        <span class="hljs-keyword">else</span> result += c;
    }
    <span class="hljs-keyword">return</span> result;
}
</div></code></pre>
<h3 id="2315-%E7%BB%9F%E8%AE%A1%E6%98%9F%E5%8F%B7-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/count-asterisks/description/">2315. 统计星号</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个字符串 s ，每 两个 连续竖线 '|' 为 一对 。换言之，第一个和第二个 '|' 为一对，第三个和第四个 '|' 为一对，以此类推。</p>
<p>请你返回 不在 竖线对之间，s 中 '*' 的数目。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>两个竖线为一对，之前书上有类似的，创建一个标志变量加上！</li>
</ul>
<h3 id="1221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/">1221. 分割平衡字符串</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>平衡字符串 中，'L' 和 'R' 字符的数量是相同的。</p>
<p>给你一个平衡字符串 s，请你将它分割成尽可能多的 平衡字符串 。</p>
<p>返回可以通过分割得到的平衡字符串的 最大数量 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>最开始想用两数统计次数，相等就输出然后再重置，又想到二元关系，用加一减一估计更好。</li>
</ul>
<h3 id="lcr-182-%E5%8A%A8%E6%80%81%E5%8F%A3%E4%BB%A4"><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/">LCR 182. 动态口令</a></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>某公司门禁密码使用动态口令技术。初始密码为字符串 <code>password</code>，密码更新均遵循以下步骤：设定一个正整数目标值 <code>target</code>；将 <code>password</code> 前 <code>target</code> 个字符按原顺序移动至字符串末尾。请返回更新后的密码字符串。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>算法书上有个题包含了此题的思想，<a href="https://blog.csdn.net/2401_88544423/article/details/154158761?spm=1001.2014.3001.5501">环状字符串最小字典序</a></li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-built_in">string</span> result;
<span class="hljs-keyword">int</span> len = password.size();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
    result += password[(i+target)%len];
</div></code></pre>
<h3 id="2114-%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%9A%E5%8D%95%E8%AF%8D%E6%95%B0-badge-type%22tip%22-text%22%E5%B7%B2%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/maximum-number-of-words-found-in-sentences/">2114. 句子中的最多单词数</a> <Badge type="tip" text="已解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>一个 句子 由一些 单词 以及它们之间的单个空格组成，句子的开头和结尾不会有多余空格。</p>
<p>给你一个字符串数组 sentences ，其中 sentences[i] 表示单个句子。</p>
<p>请你返回单个句子里 单词的 最大数目 。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>最开始cnt为0，遍历，跟每个句子的temp比较,聪明的我发现单词数就是空格加1；</li>
</ul>
<h3 id="1684-%E7%BB%9F%E8%AE%A1%E4%B8%80%E8%87%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE-badge-type%22warning%22-text%22%E6%9C%AA%E8%A7%A3%E5%86%B3%22"><a href="https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/">1684. 统计一致字符串的数目</a> <Badge type="warning" text="未解决" /></h3>
<h2 id="%E9%A2%98%E6%84%8F">题意</h2>
<p>给你一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code>。如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是<strong>一致字符串</strong>。请你返回 <code>words</code> 数组中<strong>一致字符串</strong>的数目。</p>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li><strong>set</strong>: 创建一个名为 allowedSet 的集合，它包含了 allowed 字符串中的所有字符。</li>
<li><strong>bool数组</strong>: 创建一个bool数组标记 allowed 字符。</li>
<li><strong>遍历</strong>: 暴力检查每个字符是否在 allowed 中。</li>
</ul>
<h2 id="%E4%BB%A3%E7%A0%81">代码</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Set 方法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countConsistentStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> allowed, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">allowedSet</span><span class="hljs-params">(allowed.begin(), allowed.end())</span></span>;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; word : words) {
            <span class="hljs-keyword">bool</span> consistent = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) {
                <span class="hljs-keyword">if</span> (allowedSet.find(c) == allowedSet.end()) {
                    consistent = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (consistent) count++;
        }
        <span class="hljs-keyword">return</span> count;
    }
};

<span class="hljs-comment">// Bool 数组</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countConsistentStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> allowed, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> </span>{
        <span class="hljs-keyword">bool</span> allowedChars[<span class="hljs-number">26</span>] = {<span class="hljs-literal">false</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : allowed) allowedChars[c - <span class="hljs-string">'a'</span>] = <span class="hljs-literal">true</span>;
        
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; word : words) {
            <span class="hljs-keyword">bool</span> consistent = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) {
                <span class="hljs-keyword">if</span> (!allowedChars[c - <span class="hljs-string">'a'</span>]) {
                    consistent = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (consistent) count++;
        }
        <span class="hljs-keyword">return</span> count;
    }
};
</div></code></pre>
<h1 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8">顺序表</h1>
<p><a href="https://github.com/Jaxon1216/cpp-notes/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/Sqlisttmp.cpp">顺序表源码</a></p>
<h2 id="%E5%AE%8F%E5%AE%9A%E4%B9%89">宏定义</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eletype int </span>
<span class="hljs-comment">//便于修改：如果以后想把元素类型从 int 改为 double，只需要改一行</span>
</div></code></pre>
<h2 id="%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B4">申请空间</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initializelist</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> capacity)</span></span>{
    <span class="hljs-built_in">list</span>-&gt;elements = <span class="hljs-keyword">new</span> eletype[capacity];
    <span class="hljs-comment">/* =====================【要点2｜显眼说明】===================== 
       在堆上申请了 “capacity 个 eletype 的连续内存”，并把“首地址”赋给 elements。
       注意：像 int 这类内置类型，new[] 默认不清零；若需清零可写 new eletype[capacity]();
       访问指针指向的结构体成员用 -&gt;；若 list 是对象本身（非指针）则用 .
       ========================================================= */</span>

    <span class="hljs-built_in">list</span>-&gt;size = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">list</span>-&gt;capacity = capacity;
}
</div></code></pre>
<h2 id="%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98">释放内存</h2>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroylist</span><span class="hljs-params">(Sequentiallist *<span class="hljs-built_in">list</span>)</span></span>{
    <span class="hljs-comment">// 【要点4】delete[] 释放的是 elements 当前指向的“数组内存”，不是指针变量本身</span>
    <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">list</span>-&gt;elements;
    <span class="hljs-built_in">list</span>-&gt;elements = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 置空，避免悬空指针被误用</span>
    <span class="hljs-built_in">list</span>-&gt;size = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">list</span>-&gt;capacity = <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%96%91%E9%97%AE">总结与常见疑问</h2>
<h4 id="q1%E4%B8%BA%E4%BB%80%E4%B9%88-main-%E9%87%8C%E8%A6%81%E5%86%99-initializelistlist-10">Q1：为什么 main 里要写 initializelist(&amp;list, 10)？</h4>
<ul>
<li>形参是 <code>Sequentiallist*</code>，需要“对象地址”。main 里有对象 <code>Sequentiallist list;</code>，
所以要传 <code>&amp;list</code>（取地址，类型刚好是 <code>Sequentiallist*</code>）。</li>
</ul>
<h4 id="q2%E4%BB%A5%E5%90%8E%E5%87%A1%E6%98%AF%E6%93%8D%E4%BD%9C%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%83%BD%E8%A6%81%E5%8A%A0--%E5%90%97">Q2：以后凡是“操作指针指向的对象”，都要加 <code>&amp;</code> 吗？</h4>
<ul>
<li>不。仅当“形参类型是指针 <code>T*</code>，而你手里是一个对象 <code>T</code>”时，才需要写 <code>&amp;obj</code>。
小抄：
<ul>
<li>你有对象 <code>T obj</code>，函数要 <code>T*</code>        → 传 <code>&amp;obj</code></li>
<li>你已有指针 <code>T* p</code>，函数要 <code>T*</code>         → 直接传 <code>p</code>（不要再 <code>&amp;</code>）</li>
<li>函数要引用 <code>T&amp;</code>                     → 直接传 <code>obj</code>（不用 <code>&amp;</code>）</li>
<li>函数要值 <code>T</code>（拷贝）                 → 直接传 <code>obj</code>（函数内改动不影响外部）</li>
</ul>
</li>
</ul>
<h4 id="q3%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-insert-%E7%AD%89%E5%87%BD%E6%95%B0%E9%87%8C%E4%B8%8D%E5%86%99%E6%88%90-elements">Q3：为什么在 <code>insert</code> 等函数里不写成 <code>&amp;elements</code>？</h4>
<ul>
<li>因为 <code>elements</code> 的类型已经是 <code>eletype*</code>（指向元素的指针），正是我们需要的。</li>
<li><code>&amp;elements</code> 的类型会变成 <code>eletype**</code>（指向“指针变量本身”的地址），
这既不是数组起始地址，也不是我们要用来下标访问的类型，反而会出错。</li>
<li>例如扩容时：
newelements[i] = list-&gt;elements[i];
两边都是 <code>eletype</code> 的值拷贝，<code>list-&gt;elements</code> 和 <code>newelements</code> 都是 <code>eletype*</code>，不需要再取地址。</li>
</ul>
<h4 id="q4%E5%86%8D%E5%B8%AE%E4%BD%A0%E6%8D%8B%E9%A1%BA%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E4%BE%BF%E4%BA%8E%E4%B8%80%E7%9C%BC%E8%AE%B0%E5%BF%86">Q4：再帮你捋顺几种访问方式（便于一眼记忆）</h4>
<ul>
<li>结构体指针访问成员：<code>ptr-&gt;member</code></li>
<li>结构体对象访问成员：<code>obj.member</code></li>
<li>动态数组（指针指向一段连续元素）：<code>ptr[i]</code> 等同于 <code>*(ptr + i)</code></li>
<li>何时取地址 <code>&amp;</code>：当函数要 T* 而你手上是 T；或你真的需要得到某个变量本身所在的地址。</li>
</ul>
<p>小例子：</p>
<pre class="hljs"><code><div>Sequentiallist <span class="hljs-built_in">list</span>;                 <span class="hljs-comment">// 对象</span>
initializelist(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-number">10</span>);           <span class="hljs-comment">// 形参是 Sequentiallist*，所以取地址传入</span>
Sequentiallist* p = &amp;<span class="hljs-built_in">list</span>;           <span class="hljs-comment">// p 已经是指针</span>
insert(p, <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);                    <span class="hljs-comment">// 形参是 Sequentiallist*，直接传 p，不要再加 &amp;</span>
</div></code></pre>
<h1 id="%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">单向链表</h1>
<p><a href="https://github.com/Jaxon1216/cpp-notes/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/%E6%BA%90%E7%A0%81.cpp">单向链表源码</a></p>
<h2 id="%E8%8A%82%E7%82%B9%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">节点与构造函数（初始化列表）</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    eleType data;
    ListNode* next;
    <span class="hljs-comment">// 推荐写法：使用构造函数初始化列表，next 初始化为 nullptr</span>
    ListNode(eleType x) : data(x), next(<span class="hljs-literal">nullptr</span>) {}
};
</div></code></pre>
<h2 id="%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%96%91%E9%97%AE%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">总结与常见疑问（单向链表）</h2>
<h4 id="q1%E5%8F%82%E6%95%B0%E5%90%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B8%B8%E5%86%99%E6%88%90-x">Q1：参数名为什么常写成 <code>x</code>？</h4>
<ul>
<li>只是习惯用法/占位符，表示“传入的值”。你可以改为任何更语义化的名字，如 <code>value</code>、<code>val</code>、<code>dataIn</code>。</li>
<li>核心点：构造函数通过“初始化列表”把形参的值用于初始化成员：<code>data(x)</code>。</li>
</ul>
<h4 id="q2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E8%AF%AD%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">Q2：构造函数初始化列表的语法是什么？</h4>
<ul>
<li>语法：<code>ClassName(params) : member1(init1), member2{init2} { /* body */ }</code></li>
<li><code>:</code> 后面是以逗号分隔的“成员初始化器”。可以用圆括号 <code>()</code> 或花括号 <code>{}</code> 初始化，推荐优先使用 <code>{}</code> 的一致初始化。</li>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div>ListNode(eleType value) : data{value}, next{<span class="hljs-literal">nullptr</span>} {}
</div></code></pre>
<h4 id="q3%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-vs-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E8%B5%8B%E5%80%BC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Q3：初始化列表 vs 构造函数体内赋值，有什么区别？</h4>
<ul>
<li>初始化列表：直接“构造”成员，效率更高，且某些成员只能这样初始化。</li>
<li>构造函数体内赋值：先默认构造/零初始化成员，再进行赋值；对自定义类型相当于“先构造后赋值”，多一步。</li>
<li>对于 <code>const</code> 成员、引用成员、或成员类型没有默认构造函数的场景，必须使用初始化列表。</li>
</ul>
<h4 id="q4%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9E%E9%99%85%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E6%8C%89%E4%BB%80%E4%B9%88%E6%9D%A5">Q4：成员的实际初始化顺序按什么来？</h4>
<ul>
<li>按“成员在类中声明的顺序”，而不是初始化列表里书写的顺序。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span>
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">int</span> b;
    A() : b(<span class="hljs-number">2</span>), a(<span class="hljs-number">1</span>) {} <span class="hljs-comment">// 实际顺序仍是先 a 后 b（按声明顺序）</span>
};
</div></code></pre>
<ul>
<li>建议让初始化列表的书写顺序与成员声明顺序一致，避免潜在的行为差异与编译器告警。</li>
</ul>
<h4 id="q5%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E5%BF%85%E9%A1%BB%E6%88%96%E5%BC%BA%E7%83%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">Q5：哪些场景必须或强烈建议使用初始化列表？</h4>
<ul>
<li>必须：<code>const</code> 成员、引用成员、成员类型没有默认构造函数。</li>
<li>强烈建议：大型对象或自定义类型（减少一次“构造后赋值”），以及需要为指针/句柄设定明确初值（如 <code>nullptr</code>）。</li>
</ul>
<h4 id="q6null-%E5%92%8C-nullptr-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%E6%9C%AC%E5%A4%84%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA">Q6：<code>NULL</code> 和 <code>nullptr</code> 有何区别？本处该用哪个？</h4>
<ul>
<li><code>nullptr</code> 是 C++11 引入的空指针字面量，类型安全，优先使用。</li>
<li>建议：<code>next(nullptr)</code> 而不是 <code>next(NULL)</code>。</li>
</ul>
<h4 id="q7%E4%B8%8E%E6%88%90%E5%91%98%E5%86%85%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88">Q7：与“成员内默认值”如何配合？</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    eleType data{};          <span class="hljs-comment">// 成员内默认值（统一初始化）</span>
    ListNode* next{<span class="hljs-literal">nullptr</span>}; <span class="hljs-comment">// 成员内默认值</span>
    ListNode(eleType value) : data{value} {} <span class="hljs-comment">// 显式初始化 data，next 走其默认值</span>
};
</div></code></pre>
<ul>
<li>规则：当构造函数未在初始化列表中显式初始化某成员时，成员内默认值生效；一旦显式初始化，就以初始化列表为准。</li>
</ul>
<h1 id="%E4%B8%B2">串</h1>
<h2 id="%E5%85%B3%E4%BA%8E-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%B2%E6%BA%90%E7%A0%81cpp-%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B90%E5%9F%BA%E7%A1%80%E7%89%88">关于 <code>数据结构/串/源码.cpp</code> 的关键点（0基础版）</h2>
<ul>
<li>
<ol>
<li>第一行：<code>#define _CRT_SECURE_NO_WARNINGS</code></li>
</ol>
<ul>
<li>作用：在 MSVC 编译器里关闭“使用不安全 C 函数”的警告，例如 <code>strcpy</code>、<code>strcat</code>。</li>
<li>好处：示例代码可直接编译运行；实际项目建议改用更安全的变体（如 <code>strcpy_s</code>）。</li>
<li>举例：<pre class="hljs"><code><div><span class="hljs-comment">// 目标：把 "hello" 复制到 dst</span>
<span class="hljs-keyword">char</span> dst[<span class="hljs-number">6</span>]{};                <span class="hljs-comment">// 预留 6 个字节（5 个可见字符 + 1 个'\0'）</span>
<span class="hljs-comment">// 传统接口：在 MSVC 下会有“非安全”警告</span>
<span class="hljs-built_in">strcpy</span>(dst, <span class="hljs-string">"hello"</span>);
<span class="hljs-comment">// 更安全的 MSVC 扩展接口（推荐在 MSVC 下使用）：</span>
<span class="hljs-comment">// strcpy_s(dst, sizeof(dst), "hello");</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<ol start="2">
<li>第14行 vs 第15行构造函数</li>
</ol>
<ul>
<li>第14行 <code>String(const char* s)</code>：从 C 风格字符串构造对象（形如字面量 &quot;abc&quot;）。</li>
<li>第15行 <code>String(const String&amp; s)</code>：拷贝构造，从同类对象拷贝生成新对象。</li>
<li>区别在于参数类型与用途不同：一个接收 <code>const char*</code>，一个接收 <code>const String&amp;</code>。</li>
<li>举例（它们何时被调用）：<pre class="hljs"><code><div><span class="hljs-function">String <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">"abc"</span>)</span></span>;     <span class="hljs-comment">// 调用 const char* 构造（第14行）</span>
String b = a;          <span class="hljs-comment">// 拷贝构造（第15行）</span>
<span class="hljs-function">String <span class="hljs-title">c</span><span class="hljs-params">(a)</span></span>;           <span class="hljs-comment">// 也是拷贝构造（第15行）</span>
String d = <span class="hljs-string">"xyz"</span>;     <span class="hljs-comment">// 隐式把字面量转换为临时 String，再用于初始化 d</span>
</div></code></pre>
</li>
<li>再举一个“隐式转换”例子：<pre class="hljs"><code><div><span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"12"</span>)</span></span>;
<span class="hljs-comment">// operator+ 需要一个 String；右边是 "34" 的 const char*</span>
<span class="hljs-comment">// 因为存在 String(const char*), 字面量会被“自动转换”为临时 String</span>
String t = s + <span class="hljs-string">"34"</span>;  <span class="hljs-comment">// 实际执行：s.operator+(String("34"))</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<ol start="3">
<li>第25行友元函数与第92-94行</li>
</ol>
<ul>
<li>友元声明：<code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const String&amp; s);</code></li>
<li>含义：允许该非成员函数访问 <code>String</code> 的私有成员（例如 <code>s.str</code>）。</li>
<li>为什么需要“非成员”？因为 <code>operator&lt;&lt;</code> 左边是 <code>ostream</code>（<code>cout</code>），不是 <code>String</code>，所以做成员函数不合适。</li>
<li>第92-94行实现展示了它如何直接访问 <code>s.str</code> 并返回 <code>ostream&amp;</code> 以支持链式 <code>&lt;&lt;</code>。</li>
<li>代码位置引用：<pre class="hljs"><code><div>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const String&amp; s); // 3) 友元：允许此函数访问私有成员（如 s.str）
</div></code></pre>
<pre class="hljs"><code><div>ostream&amp; operator&lt;&lt;(ostream&amp; out, const String&amp; s) { // 3) 输出运算符重载：返回 ostream&amp; 以支持链式 &lt;&lt;
    out &lt;&lt; s.str; // 3) 直接访问私有成员 str，因第25行声明其为友元
    return out; // 3) 返回输出流自身，允许 cout &lt;&lt; a &lt;&lt; b 连续输出
}
</div></code></pre>
</li>
<li>使用举例：<pre class="hljs"><code><div><span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>)</span></span>;
<span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-string">" world\n"</span>;  <span class="hljs-comment">// 等价于 operator&lt;&lt;(operator&lt;&lt;(cout, s), " world\n")</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<ol start="4">
<li>本文件用到的 <code>&lt;cstring&gt;</code> 内容</li>
</ol>
<ul>
<li><code>strlen</code>：计算 C 字符串长度（不含终止符 <code>\0</code>）。</li>
<li><code>strcpy</code>：把源 C 字符串拷贝到目标缓冲区。</li>
<li><code>strcmp</code>：按字典序比较两个 C 字符串，相等返回 0。</li>
<li><code>strcat</code>：把源 C 字符串追加到目标字符串末尾。</li>
<li>小心事项：
<ul>
<li>为 C 字符串分配空间时，务必预留终止符：长度 <code>n</code> → 申请 <code>n + 1</code>。</li>
<li><code>strcpy/strcat</code> 不会自动检查目标缓冲区大小，可能导致越界；务必保证足够空间。</li>
<li><code>strcmp(a,b)</code> 返回值：<code>0</code> 表示相等；<code>&lt;0</code> 表示 <code>a&lt;b</code>；<code>&gt;0</code> 表示 <code>a&gt;b</code>。</li>
</ul>
</li>
<li>举例：<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src = <span class="hljs-string">"abc"</span>;
<span class="hljs-keyword">size_t</span> n = <span class="hljs-built_in">strlen</span>(src);        <span class="hljs-comment">// n == 3</span>
<span class="hljs-keyword">char</span>* buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n + <span class="hljs-number">1</span>]{}; <span class="hljs-comment">// 预留 '\0'</span>
<span class="hljs-built_in">strcpy</span>(buf, src);              <span class="hljs-comment">// buf -&gt; "abc\0"</span>
<span class="hljs-built_in">strcat</span>(buf, <span class="hljs-string">"X"</span>);             <span class="hljs-comment">// 需要再多 1 个空间，否则可能越界！</span>
<span class="hljs-keyword">delete</span>[] buf;
</div></code></pre>
</li>
<li>C++ 建议：尽量使用 <code>std::string</code> 来避免手工管理 <code>\0</code> 与缓冲区大小。</li>
</ul>
</li>
<li>
<ol start="5">
<li>第61行的 <code>this</code></li>
</ol>
<ul>
<li><code>this</code> 是指向“当前对象”的指针，类型为 <code>String*</code>。</li>
<li>用法：<code>if (this != &amp;s)</code> 用来判断是否自我赋值（同一对象），避免先 <code>delete[]</code> 自己的数据导致错误。</li>
<li>举例（没有自赋值检查时的风险）：<pre class="hljs"><code><div><span class="hljs-comment">// 假设 a = a; 且没有做 this 检查：</span>
<span class="hljs-comment">// 1) 先 delete[] str;  会把 a 当前的缓冲区释放</span>
<span class="hljs-comment">// 2) 再 strcpy(str, s.str); 但 s 和 *this 是同一个对象，源数据已被删，导致未定义行为</span>
</div></code></pre>
</li>
<li>正确写法（源码第61行所在的 if 分支）：<pre class="hljs"><code><div>String&amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> String&amp; s) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;s) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 自赋值直接返回，安全</span>
    <span class="hljs-comment">// 否则再释放、再分配、再拷贝</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
</li>
</ul>
</li>
<li>
<ol start="6">
<li>第67行的 <code>*this</code></li>
</ol>
<ul>
<li><code>*this</code> 是“当前对象本身”的引用（把指针解引用后得到对象）。</li>
<li>返回 <code>*this</code>（类型 <code>String&amp;</code>）可支持链式赋值：<code>a = b = c;</code>。</li>
<li>链式赋值的原理：<pre class="hljs"><code><div><span class="hljs-function">String <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">"A"</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">"B"</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-string">"C"</span>)</span></span>;
a = b = c;     <span class="hljs-comment">// 先执行 b = c（返回 b 的引用），再执行 a = (返回值)</span>
</div></code></pre>
</li>
<li>如果返回的是“值”（而不是引用），链式赋值会产生临时对象，既低效又可能导致行为不符合预期；因此应返回 <code>*this</code> 的引用。</li>
</ul>
</li>
</ul>
<h1 id="%F0%9F%A7%A9-%E7%BA%A6%E7%91%9F%E5%A4%AB%E5%87%BA%E5%B1%80%E9%97%AE%E9%A2%98%E9%A2%98%E8%A7%A3josephus-problem">🧩 约瑟夫出局问题题解（Josephus Problem）</h1>
<hr>
<h2 id="%E9%97%AE%E9%A2%98%E7%AE%80%E4%BB%8B">问题简介</h2>
<p>有 ( n ) 个人围成一圈，从第一个开始报数，每报到第 ( k ) 个时，该人出局。
然后从下一个人重新从 1 开始报数，循环，直到所有人都出局。</p>
<blockquote>
<p>要求：输出<strong>出局顺序</strong> 或者<strong>幸存者</strong>。</p>
</blockquote>
<hr>
<ul>
<li>最开始，我是在学习数据结构刷题时遇到<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1276">士兵队列问题</a>。它是约瑟夫问题的一个变式，此处不展开。</li>
<li>之后在学校的 PTA 历史题目集中的18届现场赛A题再次遇到本题。最初用暴力法勉强通过，但在梳理过程中不断冒出新疑问、找到新思路，也发现网上资料零散，于是整理这篇题解，主要也是提升自己的理解。</li>
</ul>
<hr>
<ul>
<li>我们在做题前需要明确：
<ul>
<li>真实编号从 1 开始；本文若不特别说明，下标从 0 开始。</li>
<li>报数越过末尾需要“绕圈”，使用取模实现；注意这里的模是对“当前剩余人数”取模。</li>
<li>文中将明确“下标/编号”，避免混淆。</li>
</ul>
</li>
</ul>
<h2 id="%E6%9A%B4%E5%8A%9B%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%87%BA%E5%87%BA%E5%B1%80%E9%A1%BA%E5%BA%8F">暴力模拟输出出局顺序</h2>
<h3 id="%F0%9F%A7%A0-%E6%80%9D%E8%B7%AF">🧠 思路</h3>
<p>最直观的思路：
我们每次从 <code>people</code> 数组中删除第 <code>k</code> 个出局的人。
删除后，下一个人从 1 重新报数。</p>
<hr>
<h3 id="%F0%9F%92%BB-%E5%AE%9E%E7%8E%B0">💻 实现</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">baoli</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; people, result;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) people.push_back(i);<span class="hljs-comment">//初始化真实编号</span>
    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (!people.empty()) {
        cnt++;
        <span class="hljs-keyword">if</span> (cnt == k) {
            result.push_back(people[pos]);<span class="hljs-comment">//传值</span>
            people.erase(people.begin() + pos);<span class="hljs-comment">//动态变化，值删了，大小也变小，但是每次erase复杂度都是O（n）。</span>
            cnt = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> pos++;
        <span class="hljs-keyword">if</span> (pos &gt;= (<span class="hljs-keyword">int</span>)people.size()) pos = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> result;
}
</div></code></pre>
<hr>
<h3 id="%F0%9F%93%8A-%E7%A4%BA%E4%BE%8Bn--5-k--3%E4%B8%8E%E4%B8%8A%E6%96%87%E5%AE%9A%E4%B9%89%E4%B8%80%E8%87%B4">📊 示例：n = 5, k = 3（与上文定义一致）</h3>
<table>
<thead>
<tr>
<th style="text-align:center">轮次</th>
<th style="text-align:center">当前队列</th>
<th style="text-align:center">报数顺序</th>
<th style="text-align:center">出局者</th>
<th style="text-align:center">剩余队列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">[1,2,3,4,5]</td>
<td style="text-align:center">1,2,<strong>3</strong></td>
<td style="text-align:center">3</td>
<td style="text-align:center">[1,2,4,5]</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">[1,2,4,5]</td>
<td style="text-align:center">4,5,<strong>1</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">[2,4,5]</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">[2,4,5]</td>
<td style="text-align:center">2,4,<strong>5</strong></td>
<td style="text-align:center">5</td>
<td style="text-align:center">[2,4]</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">[2,4]</td>
<td style="text-align:center">2,4,<strong>2</strong></td>
<td style="text-align:center">2</td>
<td style="text-align:center">[4]</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">[4]</td>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center">4</td>
<td style="text-align:center">[]</td>
</tr>
</tbody>
</table>
<p>🔹 出局顺序：<strong>3 → 1 → 5 → 2 → 4</strong>
🔹 最后幸存：<strong>4号</strong></p>
<hr>
<h2 id="%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">应用数学公式</h2>
<blockquote>
<p>最开始我把自己的暴力法发给ds让他纠错，提出建议，他直接把这个数学公式应用了进来</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">baoli_math</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; people, result;
    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!people.empty()) {
        pos = (pos + k - <span class="hljs-number">1</span>) % people.size();    <span class="hljs-comment">// 这里，计算要删除的位置</span>
        result.push_back(people[pos]);          <span class="hljs-comment">// 将出局的人加入结果</span>
        people.erase(people.begin() + pos);     <span class="hljs-comment">// 从列表中删除出局的人</span>
    }
    <span class="hljs-keyword">return</span> result;
}
</div></code></pre>
<ul>
<li>因此我遇到的第一个问题是：这个公式怎么来的？如何直观理解？</li>
</ul>
<blockquote>
<p>查阅资料并结合实践，我的理解是：</p>
<ul>
<li>每一轮固定报 (1) 到 (k)，转成下标即 (0) 到 (k-1)，这就是公式中的 (k-1)。</li>
<li>当到达末尾，需要从开头继续，使用取模实现。这里的模是当前的 <code>people.size()</code>（当前剩余人数）。</li>
</ul>
</blockquote>
<h2 id="%E5%85%AC%E5%BC%8F%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">公式其他应用场景</h2>
<p>翻资料时发现，最经典的应用是只求最后的幸存者。</p>
<h3 id="%E2%9A%99%EF%B8%8F-%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF">⚙️ 核心思路</h3>
<p>数学法的本质是：</p>
<blockquote>
<p>我们不关心过程，只关心最后幸存者的位置。</p>
</blockquote>
<p>它从“反向”角度考虑：</p>
<ul>
<li>已知 (n-1) 个人时最后幸存者的下标；</li>
<li>当人数变成 (n) 时，这个位置整体右移 (k) 位；</li>
<li>若越界就取模回到前面。</li>
</ul>
<p>于是得到递推：</p>
<pre class="hljs"><code><div>f(1, k) = 0  
f(n, k) = (f(n-1, k) + k) % n
</div></code></pre>
<p>其中 <code>f(n, k)</code> 是最后幸存者的下标（0 开始）。</p>
<hr>
<h3 id="%F0%9F%A7%BE-%E4%B8%BE%E4%BE%8Bn--5-k--3">🧾 举例：n = 5, k = 3</h3>
<p>我们一步步列出：</p>
<table>
<thead>
<tr>
<th>n</th>
<th>推导公式</th>
<th>计算结果/被踢</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>f(1,3)=0</td>
<td>0</td>
<td>只有一个人，当然是选中下标0号</td>
</tr>
<tr>
<td>2</td>
<td>(0+3)%2</td>
<td>1</td>
<td>第3个是下标1号（两人中下标[0,1]）</td>
</tr>
<tr>
<td>3</td>
<td>(1+3)%3</td>
<td>1</td>
<td>上一轮幸存的事下标1号，n为3人即下标边界为2，这轮报数2，0，1，选中1</td>
</tr>
<tr>
<td>4</td>
<td>(1+3)%4</td>
<td>0</td>
<td>4人下标边界为3，在上轮下标1后开始，2，3，0，选中0</td>
</tr>
<tr>
<td>5</td>
<td>(0+3)%5</td>
<td>3</td>
<td>边界4，上轮0后开始，1，2，3，最后幸存者/选中者是3号（下标从0起）</td>
</tr>
</tbody>
</table>
<p>因此最终幸存者编号 = <strong>3 + 1 = 4号</strong>（下标加一为编号）。</p>
<hr>
<h2 id="%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">推荐使用场景</h2>
<table>
<thead>
<tr>
<th>目标</th>
<th>推荐方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出出局顺序</td>
<td>✅ 暴力模拟 / 动态删除</td>
<td>直观易懂，便于验证</td>
</tr>
<tr>
<td>只求最后幸存者</td>
<td>✅ 数学递推法</td>
<td>高效，时间复杂度 O(n)</td>
</tr>
<tr>
<td>验证理论或公式</td>
<td>✅ 数学法</td>
<td>推导简洁、递归关系清晰</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%E6%8B%93%E5%B1%951%E5%8F%AA%E8%BE%93%E5%87%BA%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E4%BC%98%E5%86%99%E6%B3%95">拓展1：只输出最后一个人（最优写法）</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">josephus_last</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)
        res = (res + k) % i;
    <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>; <span class="hljs-comment">// 从1开始编号</span>
}
</div></code></pre>
<ul>
<li>于是我遇到了<strong>第二个疑惑</strong>
<ul>
<li>为什么是2开头的？答案是f（1，k）= 0很显然；</li>
</ul>
<blockquote>
<p>虽然答案很简单，但是多想一想多写一写印象会更深点。
例如：<code>(5,3)</code> → 输出 <code>4</code>（即第4号幸存）。</p>
</blockquote>
</li>
</ul>
<h2 id="%E6%8B%93%E5%B1%952%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A118%E5%B1%8A%E7%8E%B0%E5%9C%BA%E8%B5%9Bk">拓展2：程序设计18届现场赛K</h2>
<ul>
<li>事实上，开篇约瑟夫问题还有困难版本。</li>
<li>困难版本的主要要求如下：
<ul>
<li>n 的最大值：1.5 × 10⁶。</li>
<li>输出结果：Σ(轮数 × 出局编号) mod 2⁶⁴。</li>
<li>使用 O(n²) 的暴力解法，会导致超时。</li>
</ul>
</li>
</ul>
<p>目前还不会，以下技能点均还未解锁，做不来。</p>
<h3 id="%E8%A6%81%E6%B1%82%E8%83%BD%E5%8A%9B">要求能力</h3>
<ul>
<li>🚩 <strong>算法基础</strong>
<ul>
<li>时间复杂度分析</li>
<li>二分思想</li>
<li>前缀和思想</li>
</ul>
</li>
<li>🚩 <strong>树状数组核心</strong>
<ul>
<li>单点修改 + 区间查询（log n）</li>
</ul>
</li>
<li>🚩 <strong>二分查找</strong>
<ul>
<li>在树状数组上找第 k 个 1（顺序统计）</li>
</ul>
</li>
<li>🚩 <strong>环形模拟逻辑</strong>
<ul>
<li>约瑟夫环中位置转移与取模处理</li>
</ul>
</li>
<li>🚩 <strong>大数据优化</strong>
<ul>
<li>long long / ull 防溢出</li>
<li>快速IO</li>
<li>O(n log n) 控制</li>
</ul>
</li>
</ul>
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E5%AD%A6%E6%96%B9%E6%B3%95%E6%9B%B4%E9%80%82%E5%90%88%E5%9B%B0%E9%9A%BE%E7%89%88%E6%9C%AC">为什么数学方法更适合困难版本？</h3>
<table>
<thead>
<tr>
<th>对比项</th>
<th>暴力法</th>
<th>数学方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²)</td>
<td>O(n)</td>
</tr>
<tr>
<td>n=1.5×10⁶ 时</td>
<td>约 2.25×10¹² 操作</td>
<td>1.5×10⁶ 操作</td>
</tr>
<tr>
<td>实际运行</td>
<td>严重超时</td>
<td>瞬间完成</td>
</tr>
</tbody>
</table>
<h1 id="%E7%8E%AF%E7%8A%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8Fcircular-sequence-acmicpc-seoul-2004-uva1584">环状字符串的最小字典序（Circular Sequence, ACM/ICPC Seoul 2004, UVa1584）</h1>
<hr>
<ul>
<li>作者blog：<a href="www.jiangxu.net">Jaxon</a></li>
<li><a href="https://www.jiangxu.net/study-materials/">查算法/知识点/代码分享工具/学习路线/大厂算法/八股</a></li>
</ul>
<blockquote>
<p>注：本人写题解一方面为了加深印象，另一方面为了锻炼自己的代码和逻辑能力，还有就是想变强。</p>
</blockquote>
<h2 id="%E9%97%AE%E9%A2%98%E7%AE%80%E4%BB%8B">问题简介</h2>
<p>这题要求我们给定一个环状DNA串（只包含A、C、G、T这四个字符），通过从不同位置开始读取，找出这个环状串的最小字典序表示法。说白了，环状串就是从不同位置切开然后拼起来得到的各种字符串，我们要在这些里面找到字典序最小的那个。</p>
<p>比如&quot;CGAGTCAGCT&quot;这个串，可以表示成&quot;GAGTCAGCTC&quot;、&quot;AGTCAGCTCG&quot;等等（想像成一个环）。在这些表示法里，字典序最小的就是我们要找的&quot;最小表示&quot;。</p>
<hr>
<p>在做这题之前，有几个概念得先搞清楚（我当初也是查了才知道，弄明白后理解起来就简单多了）：</p>
<ul>
<li>
<p><strong>字典序</strong>：就是按字母顺序比较，举个例子就懂了：</p>
<blockquote>
<p>比如：
&quot;ABC&quot; &lt; &quot;ABD&quot;（因为第三个字符'C'比'D'小）
&quot;AB&quot; &lt; &quot;ABC&quot;（因为&quot;AB&quot;是&quot;ABC&quot;的前缀）
&quot;AC&quot; &gt; &quot;ABD&quot;（因为第二个字符'C'比'B'大）</p>
</blockquote>
</li>
<li>
<p><strong>环状结构</strong>：既然是环状的，那走到最后肯定要回到开头，这时候用%运算符就特别方便。</p>
</li>
</ul>
<h2 id="%E6%80%9D%E8%B7%AF">思路</h2>
<ul>
<li>一开始我们不知道从哪里开始比较最小，那就干脆全都试一遍。遇到更小的就把它设为新的起始位置。</li>
<li>但要是把所有可能的字符串都生成出来再比较，效率太低了，长度大的话肯定会超时。</li>
<li>所以我们就从两个位置开始，逐个字符比较。</li>
<li>注意是环状的，用模运算处理边界问题。</li>
</ul>
<p>基于这个思路，我设计了比较函数的伪代码：</p>
<pre class="hljs"><code><div>比较位置p和q：
  对于 i 从 0 到 n-1:
    字符A = s[(p+i)%n]
    字符B = s[(q+i)%n]
    如果 A != B:
      返回 A &lt; B    //如果a小于b就返回真（1），否则返回假（0）
  返回 false（相等）
</div></code></pre>
<ul>
<li>
<p>说实话，我第一反应是想用strcmp来比较字符串，但因为环状结构的特殊性，用strcmp（比较线性）反而更麻烦。</p>
</li>
<li>
<p>试着写一下比较函数：</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">less</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*s, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{
    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i++){
        <span class="hljs-keyword">if</span>(s[(p+i)%n]!=s[(q+i)%n]) <span class="hljs-keyword">return</span> s[(p+i)%n] &lt; s[(q+i)%n];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//完全相等</span>
}
</div></code></pre>
<ul>
<li>再来考虑主函数。框架其实不难，但得想全面点，不然后面找bug更花时间，前期慢就是快嘛。
<ul>
<li>所有位置都覆盖到了吗？0~n-1</li>
<li>边界问题处理了吗？</li>
<li>特殊情况考虑了吗？比如所有字符相同、单个字符？</li>
<li>输出格式对不对？</li>
</ul>
</li>
</ul>
<p>主函数的伪代码：</p>
<pre class="hljs"><code><div>初始化 ans = 0（假设位置0最小）
对于 i 从 1 到 n-1:
  如果 位置i 比 位置ans 小:
    ans = i
从位置ans输出整个字符串
</div></code></pre>
<ul>
<li>现在写完整代码，然后测试一下：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 105</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">less</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*s, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>{
    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s);          
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ;i++){
        <span class="hljs-keyword">if</span>(s[(p+i)%n]!=s[(q+i)%n]) <span class="hljs-keyword">return</span> s[(p+i)%n] &lt; s[(q+i)%n];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//完全相等</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> T;
    <span class="hljs-keyword">char</span> s[maxn];
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T);
    
    <span class="hljs-keyword">while</span>(T--) {
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);
        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">strlen</span>(s);
        <span class="hljs-comment">// 初始化最小位置</span>
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 遍历比较所有位置</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span>(less(s, i, ans)) {
                ans = i;  <span class="hljs-comment">// 找到更小的就更新</span>
            }
        }
        <span class="hljs-comment">// 输出结果</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-built_in">putchar</span>(s[(ans+i)%n]);
        }
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ul>
<li>算一下复杂度：字符串长度N，测试用例T
<ul>
<li>strlen 是O(N)</li>
<li>while循环执行T次</li>
<li>for循环 + less函数调用是O(N²)</li>
<li>最后的输出循环是O(N)</li>
</ul>
</li>
</ul>
<p>所以总复杂度是O(T × N²)，对于题目给的数据范围完全够用了。</p>
<h2 id="%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84booth%E7%AE%97%E6%B3%95">更高效的Booth算法</h2>
<p>前面我们介绍了O(n²)的暴力解法，当长度很大时，显然会超时，通过搜索资料，我们来看看更高级的O(n)解法——Booth算法。一起学习。</p>
<h3 id="booth%E7%AE%97%E6%B3%95%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">Booth算法完整代码</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">booth</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* s)</span> </span>{
    <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">strlen</span>(s);
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) {
        <span class="hljs-keyword">char</span> a = s[(i + k) % n];
        <span class="hljs-keyword">char</span> b = s[(j + k) % n];
        
        <span class="hljs-keyword">if</span> (a == b) { 
            k++; 
            <span class="hljs-keyword">continue</span>; 
        }
        
        <span class="hljs-keyword">if</span> (a &gt; b) {
            i = i + k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (i &lt;= j) i = j + <span class="hljs-number">1</span>;
        } 
        <span class="hljs-keyword">else</span> {
            j = j + k + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (j &lt;= i) j = i + <span class="hljs-number">1</span>;
        }
        k = <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-keyword">int</span> ans = i &lt; j ? i : j;
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="booth%E7%AE%97%E6%B3%95%E6%80%8E%E4%B9%88%E7%94%A8">Booth算法怎么用</h3>
<pre class="hljs"><code><div>    <span class="hljs-keyword">while</span>(T--) {
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, s);
        <span class="hljs-keyword">int</span> ans = booth(s);  <span class="hljs-comment">// 直接用Booth算法找最小位置      </span>
        <span class="hljs-comment">// 输出结果（跟之前一样）</span>
    }
</div></code></pre>
<h3 id="%E5%8F%8C%E6%8C%87%E9%92%88%E7%AB%9E%E4%BA%89">双指针竞争</h3>
<ul>
<li><code>i</code> 和 <code>j</code> 像两个选手在比赛</li>
<li>它们从相邻位置开始比较（i=0, j=1）</li>
<li><code>k</code> 记录当前已经匹配的字符数</li>
</ul>
<h3 id="%E6%99%BA%E8%83%BD%E8%B7%B3%E8%B7%83---%E7%B2%BE%E9%AB%93">智能跳跃 - 精髓！</h3>
<p>当发现某个位置不可能是最小值时，直接跳到下一个可能的位置，跳过中间那些肯定更大的位置。</p>
<p><strong>举个例子</strong>：
假设字符串是&quot;abcabc&quot;，比较i=0和j=1：</p>
<ul>
<li>前3个字符都相同（k=3）</li>
<li>第4个字符：i位置是'a'，j位置是'b'</li>
<li>因为'a' &lt; 'b'，所以j位置肯定不是最小，直接跳到j=4</li>
</ul>
<h3 id="3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%B7%B3%E9%82%A3%E4%B9%88%E8%BF%9C">3. 为什么能跳那么远？</h3>
<p>因为如果前k个字符都相同，第k+1个字符不同，那么：</p>
<ul>
<li>输的那一方（字符较大的）及其后面k个位置都不可能是最小表示</li>
<li>所以直接跳到 <code>当前位置 + k + 1</code></li>
</ul>
<h2 id="%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94">复杂度对比</h2>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>暴力法</td>
<td>O(n²)</td>
<td>n ≤ 1000，代码简单</td>
</tr>
<tr>
<td>Booth算法</td>
<td>O(n)</td>
<td>n &gt; 1000，需要高效</td>
</tr>
</tbody>
</table>
<h2 id="%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95">实际测试</h2>
<p>两种方法都试过：</p>
<ul>
<li>当n=100时，两种方法速度差不多</li>
<li>当n=10000时，暴力法要等好几秒，Booth算法瞬间出结果</li>
<li>当n=100000时，暴力法直接超时，Booth算法依然很快</li>
</ul>
<h2 id="%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">使用建议</h2>
<ol>
<li><strong>比赛时</strong>：如果n≤1000，用暴力法更稳妥（不容易写错）</li>
<li><strong>大数据时</strong>：n&gt;10000，一定要用Booth算法</li>
<li><strong>学习时</strong>：两种都要会，理解思想更重要</li>
</ol>
<h1 id="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3c%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">深入理解C++构造函数与运算符重载</h1>
<blockquote>
<ul>
<li>本文记录了我在学习《算法竞赛入门》第五章时对C++构造函数和运算符重载的深入理解，解决了几个困扰我的问题。</li>
<li>基于本人低水平的写作勿喷。</li>
<li><a href="jiangxu.net">Jaxon's-blog</a></li>
<li><a href="https://www.jiangxu.net/study-materials/">查算法/知识点/代码分享工具/学习路线/大厂算法/八股</a></li>
<li>大学生食用<a href="https://www.jiangxu.net/Nature-of-University/">大学本质</a></li>
</ul>
</blockquote>
<h2 id="%E5%8E%9F%E6%96%87%E4%BB%A3%E7%A0%81">原文代码</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> {</span>
    <span class="hljs-keyword">int</span> x, y;
    Point(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>):x(x),y(y) {}
};

Point <span class="hljs-keyword">operator</span> + (<span class="hljs-keyword">const</span> Point&amp; A, <span class="hljs-keyword">const</span> Point&amp; B) {
    <span class="hljs-keyword">return</span> Point(A.x+B.x, A.y+B.y);
}

ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="hljs-keyword">const</span> Point&amp; p) {
    out &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> out;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Point a, b(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    a.x = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>再来看看作者的解释：</p>
<pre class="hljs"><code><div>上面的代码多数可以&quot;望文知义&quot;。
结构体Point中定义了一个函数,函数名也叫Point,但是没有返回值。
这样的函数称为构造函数(ctor)。
构造函数是在声明变量时调用的,例如,声明Pointa,b(1,2)时,
分别调用了Point( )和Point(1,2)。
注意这个构造函数的两个参数后面都有&quot;=0&quot;字样,其中0为默认值。
也就是说,如果没有指明这两个参数的值,就按0处理,
因此Point( )相当于Point(0,0)。
&quot;:x(x),y(y)&quot;则是一个简单的写法,表示&quot;把成员变量x初始化为参数x,
成员变量y初始化为参数y&quot;。
</div></code></pre>
<p>虽然之前也了解过构造函数和运算符重载的概念，但真正看到这样完整的应用时，我还是产生了几个疑问：</p>
<hr>
<h2 id="%E9%97%AE%E9%A2%981%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%8D%E5%BF%85%E9%A1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%90%8D%E7%9B%B8%E5%90%8C">问题1：为什么构造函数名必须与结构体/类名相同？</h2>
<p><strong>对比示例：</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 构造函数 - 与结构体同名，自动调用</span>
<span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;     <span class="hljs-comment">// 编译器知道调用Point(int, int)</span>

<span class="hljs-comment">// 如果是普通函数名，就无法实现自动构造</span>
Point p = createPoint(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">// 需要显式调用，不够直观</span>
</div></code></pre>
<p><strong>理解：</strong></p>
<p>这是C++的语法设计，有几个重要原因：</p>
<ol>
<li><strong>明确标识</strong>：让编译器清楚地知道这是构造对象的特殊函数</li>
<li><strong>自动调用</strong>：在对象创建时编译器能自动识别并调用构造函数</li>
<li><strong>类型安全</strong>：确保创建的对象类型正确无误</li>
</ol>
<h2 id="%E9%97%AE%E9%A2%982%E4%B8%A4%E4%B8%AA%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB">问题2：两个<code>&amp;</code>的作用与区别？</h2>
<p>搜了一下资料，一个叫做参数引用，还有一个是返回引用。</p>
<ul>
<li><strong>参数引用</strong>，这个很简单，稍微看一眼。</li>
</ul>
<blockquote>
<p>原因两点：
对于大型结构体，值传递会产生完整的对象拷贝，而引用传递直接操作原对象，区别如下：</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// 值传递 - 创建副本</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPoint</span><span class="hljs-params">(Point p)</span> </span>{ ... }

<span class="hljs-comment">// 引用传递 - 直接操作原对象</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPoint</span><span class="hljs-params">(Point&amp; p)</span> </span>{ ... }

<span class="hljs-comment">// 常量引用传递 - 直接操作原对象，但保证不修改</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p)</span> </span>{ ... }
</div></code></pre>
<blockquote>
<p>使用const引用可以在避免拷贝的同时防止函数内部修改原对象，比如：</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">// 可以读取但不能修改参数</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculateDistance</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p1, <span class="hljs-keyword">const</span> Point&amp; p2)</span> </span>{
    <span class="hljs-comment">// p1.x = 10;  // 错误！不能修改const引用</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));
}
</div></code></pre>
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%94%BE%E5%9C%A8ostream%E5%90%8E%E9%9D%A2">为什么&amp;要放在ostream后面？</h3>
<p>再来看一下代码</p>
<pre class="hljs"><code><div>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="hljs-keyword">const</span> Point&amp; p) {
    out &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> out;
}
</div></code></pre>
<ul>
<li><strong>这是返回类型的引用</strong></li>
</ul>
<p>原因是实现链式调用。链式调用，顾名思义，就像<code>cout &lt;&lt; a &lt;&lt; b &lt;&lt; c</code>一样，但是重载之后可以加入字符之类的东西，如下：</p>
<h4 id="%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8Bostream%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF">我们需要了解一下<code>ostream</code>是什么东西：</h4>
<blockquote>
<p>具体的可以看文章末尾补充内容</p>
</blockquote>
<p><code>ostream（输出流）</code>是C++中负责所有输出操作的类。我们常用的<code>cout</code>就是<code>ostream</code>的一个具体对象。</p>
<blockquote>
<p>太抽象了我们来做个比方：</p>
</blockquote>
<p>想象你在用<strong>一支笔</strong>写字：</p>
<pre><code>ostream对象 = 你手中的笔

&lt;&lt;操作 = 用笔写字

返回引用 = 继续用同一支笔写下一个字
</code></pre>
<p><strong>链式书写过程</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c;
</div></code></pre>
<p>这个书写过程：</p>
<ol>
<li>
<p>第一个字：<code>cout &lt;&lt; a</code></p>
<ul>
<li>
<p>用笔写下a的内容</p>
</li>
<li>
<p>笔不换，手不抬，准备写下一个字（返回同一支笔的引用）</p>
</li>
</ul>
</li>
<li>
<p>第二个字：<code>(同一支笔) &lt;&lt; b</code></p>
<ul>
<li>
<p>继续用同一支笔写下b的内容</p>
</li>
<li>
<p>笔迹连贯，书写流畅</p>
</li>
</ul>
</li>
<li>
<p>第三个字：<code>(同一支笔) &lt;&lt; c</code></p>
<ul>
<li>
<p>还是用这支笔写下c的内容</p>
</li>
<li>
<p>所有字都是用同一支笔连贯写出的</p>
</li>
</ul>
</li>
</ol>
<p>意思就是返回你<code>传入的输出流</code>，可能是out，也可能是别的</p>
<p><strong>用这个例子实际调用过程：</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"坐标："</span> &lt;&lt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">"结束"</span>;
</div></code></pre>
<p>编译器会把他解释为</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 编译器看到的：</span>
((<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"坐标："</span>) &lt;&lt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-string">"结束"</span>;
</div></code></pre>
<p><strong>现在分步执行</strong>：</p>
<p><strong>步骤1：cout &lt;&lt; &quot;坐标：&quot;</strong></p>
<ul>
<li>
<p>这是内置的字符串输出操作</p>
</li>
<li>
<p>返回： cout的引用（这样我们才能继续使用它）</p>
</li>
</ul>
<p><strong>步骤2：(步骤1的结果) &lt;&lt; Point(1,2)</strong></p>
<ul>
<li>
<p>步骤1返回了cout的引用，所以实际上是：cout &lt;&lt; Point(1,2)</p>
</li>
<li>
<p>调用我们重载的运算符函数</p>
</li>
<li>
<p>关键： 这里必须返回cout的引用，否则下一步无法执行</p>
</li>
</ul>
<p><strong>步骤3：(步骤2的结果) &lt;&lt; &quot;结束&quot;</strong></p>
<ul>
<li>
<p>如果步骤2返回了cout的引用，那么就是：cout &lt;&lt; &quot;结束&quot;</p>
</li>
<li>
<p>如果步骤2没有返回值，这里就没有操作对象</p>
</li>
</ul>
<p><strong>如果返回的是副本（不加引用）...</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 错误版本：返回副本</span>
ostream <span class="hljs-keyword">operator</span> &lt;&lt; (ostream out, <span class="hljs-keyword">const</span> Point&amp; p) {
    out &lt;&lt; p.toString();
    <span class="hljs-keyword">return</span> out;  <span class="hljs-comment">// 返回新的笔！</span>
}
</div></code></pre>
<p>基本上会报错的，如果允许运行拷贝了，输出可能乱序丢失或者根本看不到。</p>
<p>这就好比：</p>
<ul>
<li>写第一个字后，把笔放下</li>
<li>换一支新笔来写第二个字</li>
<li>再换一支笔写第三个字</li>
<li>每换一次笔，笔迹可能不同，书写不连贯</li>
<li>效率低下，体验很差</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>
<p><strong>参数中的引用</strong> (<code>const Point&amp;</code>)：</p>
<ul>
<li>主要目的：避免不必要的对象拷贝</li>
<li>使用场景：大型对象、需要保持原对象不被修改</li>
<li>关键优势：提高性能，减少内存占用</li>
</ul>
</li>
<li>
<p><strong>返回类型中的引用</strong> (<code>ostream&amp;</code>)：</p>
<ul>
<li>主要目的：支持链式调用</li>
<li>使用场景：流操作、赋值操作等需要连续调用的场景</li>
<li>关键优势：代码更简洁，表达力更强</li>
</ul>
</li>
</ul>
<h2 id="%E9%97%AE%E9%A2%983%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%90%8E%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97%E5%90%97%E6%98%AF%E4%B8%8D%E6%98%AF%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8A%A0%E5%8F%B7%E5%8F%AA%E8%83%BD%E7%BB%99point%E7%B1%BB%E7%94%A8%E4%BA%86">问题3：运算符重载后会影响其他类型的运算吗？是不是后面的加号只能给Point类用了？</h2>
<p><strong>验证代码：</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span>;
    <span class="hljs-keyword">double</span> m = <span class="hljs-number">1.5</span>, n = <span class="hljs-number">2.5</span>;
    
    <span class="hljs-built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 使用重载的Point加法</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 使用内置的int加法（不受影响！）</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; m + n &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 使用内置的double加法（不受影响！）</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p><strong>核心原理：</strong></p>
<p>运算符重载是基于操作数类型的，C++会根据操作数的具体类型选择对应的运算符实现，这是一个<strong>增加功能</strong>而非<strong>替换功能</strong>的过程。</p>
<h2 id="%E9%97%AE%E9%A2%984%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-xxyy-%E5%88%B0%E5%BA%95%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88">问题4：初始化列表 <code>:x(x),y(y)</code> 到底在做什么？</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// 初始化列表方式（推荐）</span>
Point(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>):x(x),y(y) {}

<span class="hljs-comment">// 传统赋值方式</span>
Point(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>) {
    <span class="hljs-keyword">this</span>-&gt;x = x;    <span class="hljs-comment">// 这是赋值，不是初始化！</span>
    <span class="hljs-keyword">this</span>-&gt;y = y;
}
</div></code></pre>
<p><strong>优势对比：</strong></p>
<ol>
<li><strong>性能更好</strong>：初始化列表直接初始化成员，避免先默认构造再赋值</li>
<li><strong>必须使用的情况</strong>：const成员和引用成员必须在初始化列表中初始化</li>
<li><strong>代码更清晰</strong>：明确区分初始化与赋值</li>
</ol>
<h2 id="%E4%BB%B7%E5%80%BC">价值</h2>
<h3 id="%E7%AE%80%E6%B4%81">简洁</h3>
<p><strong>传统写法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 创建和操作Point</span>
Point a, b, c;
a.x = <span class="hljs-number">1</span>; a.y = <span class="hljs-number">2</span>;
b.x = <span class="hljs-number">3</span>; b.y = <span class="hljs-number">4</span>;
c.x = a.x + b.x;
c.y = a.y + b.y;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%d,%d)\n"</span>, c.x, c.y);
</div></code></pre>
<p><strong>现代C++写法：</strong></p>
<pre class="hljs"><code><div><span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;
<span class="hljs-built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>代码量减少60%以上，逻辑更加清晰。</p>
<h3 id="%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%A2%9E%E5%BC%BA">可维护性增强</h3>
<p>当需要修改Point的输出格式时：</p>
<ul>
<li><strong>传统方式</strong>：需要找到所有<code>printf</code>或<code>cout</code>语句逐个修改</li>
<li><strong>重载方式</strong>：只需修改输出运算符重载函数，一处修改，全局生效</li>
</ul>
<hr>
<h2 id="%E8%A1%A5%E5%85%85%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90ostream%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">补充：深入解析ostream对象与引用传递</h2>
<h3 id="%E7%94%A8%E7%AC%94%E5%86%99%E5%AD%97%E7%9A%84%E5%AE%8C%E6%95%B4%E6%AF%94%E5%96%BB">用笔写字的完整比喻</h3>
<p>让我们继续用笔写字的比喻，但这次更深入细节：</p>
<pre class="hljs"><code><div>cout          = 你的右手（主笔）
ostream &amp;out  = 你借给别人的笔
return out    = 别人把笔还给你
</div></code></pre>
<h3 id="%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81">详细解析代码</h3>
<pre class="hljs"><code><div>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="hljs-keyword">const</span> Point&amp; p) {
    out &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> out;
}
</div></code></pre>
<h3 id="1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E5%87%BA%E7%8E%B0cout%E4%B9%9F%E8%83%BD%E8%BE%93%E5%87%BA">1. 为什么没出现cout也能输出？</h3>
<p><strong>关键理解：</strong> <code>out</code> 就是传入的&quot;笔&quot;，它可能是<code>cout</code>，也可能是其他输出流！</p>
<p><strong>比喻说明：</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 当你写：</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pointObj;

<span class="hljs-comment">// 相当于：</span>
<span class="hljs-comment">// 1. 你把右手（cout）借给了operator&lt;&lt;函数</span>
<span class="hljs-comment">// 2. operator&lt;&lt;函数用你的右手写字</span>
<span class="hljs-comment">// 3. 然后把右手还给你继续使用</span>
</div></code></pre>
<p><strong>实际调用过程：</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;
    
    <span class="hljs-comment">// 编译器看到这行代码：</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; p;
    
    <span class="hljs-comment">// 实际上转换为：</span>
    <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">cout</span>, p);  <span class="hljs-comment">// 把cout作为第一个参数传入！</span>
}
</div></code></pre>
<h3 id="2-%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5">2. 传入的参数是什么？从哪里来？</h3>
<p><strong>参数来源：</strong></p>
<ul>
<li>第一个参数 <code>ostream &amp;out</code>：来自<code>&lt;&lt;</code>左边的ostream对象</li>
<li>第二个参数 <code>const Point&amp; p</code>：来自<code>&lt;&lt;</code>右边的Point对象</li>
</ul>
<p><strong>调用链分析：</strong></p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"结果："</span> &lt;&lt; pointA &lt;&lt; <span class="hljs-string">"和"</span> &lt;&lt; pointB;

<span class="hljs-comment">// 执行过程：</span>
<span class="hljs-number">1.</span> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"结果："</span>     → 返回<span class="hljs-built_in">cout</span>的引用
<span class="hljs-number">2.</span> (返回的<span class="hljs-built_in">cout</span>) &lt;&lt; pointA → 调用我们的重载函数，传入<span class="hljs-built_in">cout</span>和pointA
<span class="hljs-number">3.</span> (返回的<span class="hljs-built_in">cout</span>) &lt;&lt; <span class="hljs-string">"和"</span>   → 返回<span class="hljs-built_in">cout</span>的引用  
<span class="hljs-number">4.</span> (返回的<span class="hljs-built_in">cout</span>) &lt;&lt; pointB → 再次调用我们的重载函数，传入<span class="hljs-built_in">cout</span>和pointB
</div></code></pre>
<h3 id="3-ostream%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">3. ostream的对象到底是什么？</h3>
<p><strong>ostream对象类型：</strong></p>
<ul>
<li><code>cout</code> - 标准输出（控制台）</li>
<li><code>cerr</code> - 标准错误输出</li>
<li><code>clog</code> - 标准日志输出</li>
<li><code>ofstream</code> - 文件输出流</li>
<li><code>ostringstream</code> - 字符串输出流</li>
</ul>
<p><strong>代码演示多种ostream对象：</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> {</span>
    <span class="hljs-keyword">int</span> x, y;
    Point(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>):x(x),y(y) {}
};

<span class="hljs-comment">// 同一个函数，可以用于各种"笔"！</span>
ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;笔, <span class="hljs-keyword">const</span> Point&amp; 点) {
    笔 &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; 点.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; 点.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> 笔;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>;
    
    <span class="hljs-comment">// 用不同的"笔"写同一个Point</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-built_in">endl</span>;                    <span class="hljs-comment">// 写到屏幕</span>
    
    ofstream 文件笔(<span class="hljs-string">"output.txt"</span>);
    文件笔 &lt;&lt; p &lt;&lt; <span class="hljs-built_in">endl</span>;                  <span class="hljs-comment">// 写到文件</span>
    
    <span class="hljs-built_in">ostringstream</span> 字符串笔;
    字符串笔 &lt;&lt; p;                        <span class="hljs-comment">// 写到字符串</span>
    <span class="hljs-built_in">string</span> 结果 = 字符串笔.str();
    
    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"错误信息: "</span> &lt;&lt; p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 写到错误输出</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="4-%E8%BF%94%E5%9B%9E%E7%9A%84%E5%BC%95%E7%94%A8%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">4. 返回的引用到底是什么？</h3>
<p><strong>返回的就是传入的那支&quot;笔&quot;！</strong></p>
<pre class="hljs"><code><div>ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;笔, <span class="hljs-keyword">const</span> Point&amp; 点) {
    笔 &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; 点.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; 点.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> 笔;  <span class="hljs-comment">// 返回的就是传入的那支笔！</span>
}
</div></code></pre>
<p><strong>内存层面的理解：</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// 假设cout在内存中的地址是0x1000</span>
<span class="hljs-built_in">cout</span> &lt;&lt; pointA;

<span class="hljs-comment">// 调用过程：</span>
<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">cout</span>, pointA)
<span class="hljs-comment">// 传入：out是cout的引用（相当于cout的别名，都指向0x1000）</span>
<span class="hljs-comment">// 返回：还是指向0x1000的引用</span>
</div></code></pre>
<h3 id="5-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A8%A1%E6%8B%9F">5. 完整的调用过程模拟</h3>
<p>让我们模拟一个完整的链式调用：</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"点坐标: "</span> &lt;&lt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">" 结束"</span>;

<span class="hljs-comment">// 逐步分解：</span>
步骤<span class="hljs-number">1</span>: <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"点坐标: "</span> 
        → 返回<span class="hljs-built_in">cout</span>的引用（假设叫temp1）

步骤<span class="hljs-number">2</span>: temp1 &lt;&lt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
        → 调用<span class="hljs-keyword">operator</span>&lt;&lt;(temp1, Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))
        → 在函数内：temp1 &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">")"</span>
        → 返回temp1的引用（还是同一个<span class="hljs-built_in">cout</span>）

步骤<span class="hljs-number">3</span>: (返回的<span class="hljs-built_in">cout</span>) &lt;&lt; <span class="hljs-string">" 结束"</span>
        → 继续输出
</div></code></pre>
<h3 id="6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E8%AE%BE%E8%AE%A1%E5%A6%82%E6%AD%A4%E5%B7%A7%E5%A6%99">6. 为什么这个设计如此巧妙？</h3>
<p><strong>灵活性：</strong> 同一支&quot;笔法&quot;可用于各种&quot;笔&quot;</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 教过一次怎么写Point后：</span>
<span class="hljs-built_in">cout</span> &lt;&lt; point;        <span class="hljs-comment">// 写到屏幕</span>
文件流 &lt;&lt; point;      <span class="hljs-comment">// 写到文件  </span>
网络流 &lt;&lt; point;      <span class="hljs-comment">// 写到网络</span>
字符串流 &lt;&lt; point;    <span class="hljs-comment">// 写到字符串</span>
</div></code></pre>
<p><strong>一致性：</strong> 自定义类型用起来和内置类型一样</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> num = <span class="hljs-number">42</span>;
<span class="hljs-function">Point <span class="hljs-title">pt</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;

<span class="hljs-comment">// 用法完全一致！</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"数字: "</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"坐标: "</span> &lt;&lt; pt &lt;&lt; <span class="hljs-built_in">endl</span>;
</div></code></pre>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<ul>
<li><strong><code>out</code>参数</strong>：就是调用时<code>&lt;&lt;</code>左边的ostream对象（可能是cout，也可能是其他输出流）</li>
<li><strong>为什么能输出</strong>：因为<code>out</code>就是传入的输出流，在函数内部用<code>out</code>来输出</li>
<li><strong>返回的引用</strong>：就是传入的那个ostream对象本身，确保链式调用时用同一支&quot;笔&quot;</li>
<li><strong>设计优势</strong>：让自定义类型的输出与内置类型完全一致，支持各种输出流</li>
</ul>
<p>这种设计体现了C++的&quot;抽象&quot;和&quot;泛型&quot;思想：一次定义，到处使用！</p>

</body>
</html>
