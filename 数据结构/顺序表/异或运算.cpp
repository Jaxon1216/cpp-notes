// 给你一个数组 nums ，数组中的数字 要么 出现一次，要么 出现两次。
// 请你返回数组中所有出现两次数字的按位 XOR 值，如果没有数字出现过两次，返回 0 。

// 位运算快速说明：
// << 左移：把二进制整体向左移动 n 位，右侧补 0（≈ 乘 2^n）
// & 按位与：两位都为 1 才为 1（常用于检测某一位是否为 1）
// |= 按位或并赋值：把某些位“置为 1”（开关打开）
// ^= 按位异或并赋值：相同为 0，不同为 1（常用于“切换某位”或“去重/累加异或”）
//
// 00000000000000 风格位演示（右边是第 0 位，LSB）：
// visited = 00000000000000
// mask = (1u << 3) = 00000000001000    // << 左移，把第 0 位的 1 移到第 3 位
// visited |= mask   -> 00000000001000   // |= 置为 1
// visited & mask    -> 00000000001000   // & 检查该位是否为 1（非 0 表示为 1）
// visited ^= mask   -> 00000000000000   // ^= 切换该位（1 变 0）
// (mask << 2)       -> 00000000100000   // 再左移两位（≈ 乘 4）
//
// Tips：若位索引可能很大，为避免 1<<idx 的 32 位溢出，可用 1LL<<idx 或 1ULL<<idx。

//xor 异或运算
// 0 异或 0 = 0
// 0 异或 1 = 1
// 1 异或 0 = 1
// 1 异或 1 = 0

class Solution {
    public:
        int xorOperation(vector<int>& nums) {
            int ans = 0;
            long long visited = 0 ;
            for(int i = 0; i < nums.size(); i++){
                if(visited & ((long long)1<<nums[i])){
                    ans ^= nums[i];
                }
                else visited |= ((long long)1<<nums[i]);// ｜ 有1则1
            }
            return ans;
        }
    };      
 
// 基于题意的解读与本实现思路：
// - 题意：数组中每个数字只会出现 1 次或 2 次；返回所有“出现了 2 次”的数字的按位异或结果，没有则返回 0。
// - 思路：用位集 visited 记录“是否出现过”。第 i 位代表数值 i：
//   - 若 (visited & (1<<x)) 非 0，说明 x 之前已出现，现在是第二次 => ans ^= x；
//   - 否则首次出现 => visited |= (1<<x)。
// - 正确性：仅在“第二次出现”时才异或该数；出现 1 次的不参与；出现 2 次的恰好被异或 1 次，最终 ans 即为所有“出现两次”的数的异或。
// - 复杂度：时间 O(n)，空间 O(1)（视位宽为常数）。若 x 可能较大，请改为 (1LL<<x)/(1ULL<<x) 或使用哈希集合，避免移位溢出。
// - 示例：nums = [1,3,2,3,4,1] -> 第二次出现的是 1 和 3，故 ans = 1 ^ 3。
//
// 详解 1<<nums[i] 操作：
// 1<<nums[i] 表示将数字 1 左移 nums[i] 位，创建一个"掩码"（mask）
// 
// 具体示例：
// 假设 nums[i] = 3，那么 1<<3 的过程是：
//   1 的二进制：        00000000000001
//   左移 3 位后：       00000000001000  （这就是 2^3 = 8）
//
// 假设 nums[i] = 5，那么 1<<5 的过程是：
//   1 的二进制：        00000000000001
//   左移 5 位后：       00000000100000  （这就是 2^5 = 32）
//
// 实际运用场景：
//   visited = 00000000000000  （初始状态）
//   nums[i] = 3 时：
//   mask = 1<<3 = 00000000001000
//   visited & mask = 00000000000000 & 00000000001000 = 0 （第3位未被标记）
//   然后 visited |= mask 变成 00000000001000 （标记第3位）
//
//   下次再遇到 nums[j] = 3 时：
//   mask = 1<<3 = 00000000001000
//   visited & mask = 00000000001000 & 00000000001000 = 非0 （第3位已被标记）
//   说明数字3已经出现过，这是第二次出现！
//
// 总结：1<<nums[i] 把数值 nums[i] 转换成对应的"位位置标记"，用于快速检查该数字是否已出现过。